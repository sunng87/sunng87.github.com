<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Here comes the Sun</title>
  <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/"/>
  <link rel="self" type="application/atom+xml" href="http://sunng87.github.io/blog/blog/blog/categories/手艺/atom.xml"/>
  <id>http://sunng87.github.io/blog/blog/</id>
  <updated>2012-12-24T00:00:00+08:00</updated>
  <generator uri="http://octopress.org/">Octopress</generator>
  
  <rights>Copyright © 2015, Sun Ning</rights>

  <entry>
    <title type="html">OSM Reporter</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2012/12/24/osm-reporter/"/>
    
    <id>/blog/2012/12/24/osm-reporter</id>
    <published>2012-12-24T00:00:00+08:00</published>
    <updated>2012-12-24T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>好久没有Weekend project了，礼拜天给一个叫作<a href="https://github.com/timlinux/osm-reporter">osm reporter</a>的小项目写了一点代码。这个小程序的功能很简单，显示指定区域里建筑物的贡献者情况。</p>

<p>我做了一些修改，增加了道路贡献情况。还有，利用自己的heatcanvas库显示用户个人编辑的分布情况。</p>

<p><a href=" http://reporter.fluv.io/?bbox=118.51638793945312,31.92943755974919,119.16183471679688,32.133175697091374&obj=highway">这里</a>有一个live demo，显示南京的编辑情况，不幸而又庆幸的是，离开南京大半年，我已经远远落后于sinopitt了。</p>

<p>这个项目的缘起：<a href="http://linfiniti.com/2012/12/holiday-openstreetmap-project-for-swellendam/">http://linfiniti.com/2012/12/holiday-openstreetmap-project-for-swellendam/</a></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Adding -var-missing to Clojure Namespace</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2012/10/27/adding-var-missing-to-clojure-namespace/"/>
    
    <id>/blog/2012/10/27/adding-var-missing-to-clojure-namespace</id>
    <published>2012-10-27T00:00:00+08:00</published>
    <updated>2012-10-27T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p><h3>Motivation</h3></p>

<p>I Just need some mechanism like "methondMissing" in Ruby. When a nonexistent var is called, the lookup system will try to call a "-var-missing" function in the namespace. This function should return a var and clojure compiler assumes this var as the one it was looking for.</p>

<p>For example, in the shake library:<br />
[cc lang="clojure"]<br />
(ns shake.core)</p>

<p>(defn -var-missing [sym]<br />
  (create-executable-var sym))<br />
[/cc]</p>

<p>To support lazy loading, shake 0.3.0 won't read your path. It will now create vars on demand. So on calling sh/uname, a var named `uname` will be created. And to create a var, just use intern or eval.</p>

<p>[cc lang="clojure"]<br />
(require '[shake.core :as sh])<br />
(sh/uname -a)<br />
[/cc]</p>

<p><h3>How to</h3></p>

<p>I'm sorry there is no way to implement this except hacking into Clojure's compiler. Fortunately, it's not too difficult to find out the injection point. </p>

<p>As you may know, there are two phases in Clojure compiler: expanding macros and evaluating forms. Both phases will look up vars to find macros or values. So we should take care both of them.</p>

<p>All code diff is here:
<script src="https://gist.github.com/3962750.js?file=Compiler.java"></script></p>

<p><h3>Conclusion</h3>
Adding -var-missing is just an attempt to implement lazy loading of vars. And it provides another smooth syntax for writing DSLs. But actually, Clojure's macro system provides a great metaprogramming mechanism. So in most case, you don't have to hack into the Compiler like this. Just put your DSL into a top level macro, and you can get them done all in clojure scripts. </p>

<p></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">更新了stages</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2012/07/13/%E6%9B%B4%E6%96%B0%E4%BA%86stages/"/>
    
    <id>/blog/2012/07/13/更新了stages</id>
    <published>2012-07-13T00:00:00+08:00</published>
    <updated>2012-07-13T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p><a href="https://github.com/sunng87/stages">Stages</a>原先是业余时间开发的一个简单的框架，用来实现SEDA。不过现在这个库经过同事们的加强，已经用在了美味和zeen的生产环境。最近我也对开源的这个分支做了一些修改。</p>

<p>首先是使用更安全的线程池，现在必须指定任务积压后的策略，即RejectionHandler。用户也可以设置自己的Queue，并且指定允许的大小。这是之前应该要做但是一直没做的事情。</p>

<p>其次在Task上增加了一个priority属性，如果你使用的是PriorityBlockingQueue，那么任务会根据这个优先级排序。但是由于PriorityBlockingQueue是unbounded，所以请慎用这个功能。</p>

<p>另外，现在所有的Task都通过perf4j计时，你可以用过配置log4j打印出性能报表日志。也可以通过JMX将耗时情况发布出去，我们在生产环境里通过ganglia监控了这些数据，还是比较有参考价值的。</p>

<p>最后，现在jmx监控stage积压队列的功能终于实现了。我会把每个队列的pending tasks数量通过mbean暴露出来，同样可以配置监控这个数据。有了这个数据后，我们可以很明确地了解各个stage的压力情况，调整线程池的策略。</p>

<p><img src="http://i.imgur.com/ashLh.png" alt="" /></p>

<p></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">多线程服务器</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2012/04/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <id>/blog/2012/04/12/多线程服务器</id>
    <published>2012-04-12T00:00:00+08:00</published>
    <updated>2012-04-12T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>写了挺长时间网络程序了，有些事到最近才弄明白，记录一下。</p>

<p>写一个高性能的服务器，传统的BIO方式基本上已经被淘汰了，很难获得理想的性能。所以现在都是以事件驱动的方式来写，在Linux上用epoll,Java平台上就是NIO。再向上，有一些包装的库，比如twisted比如libevent比如Java上的Netty。</p>

<p>Netty的server需要至少两组线程，BossPool和WorkerPool,。前者负责accept，后者负责r/w。通常的例子里，这就是仅有的两组线程。用户在框架之上的业务逻辑，写在handler里，以单线程的方式运行在worker线程上。</p>

<p>这样的方式在很多例子里很普遍。但是如果handler里的业务逻辑比较复杂，尤其是IO的等待过长(比如查询数据库)，就会由于在handler上阻塞的时间过长，导致服务器读写的效率下降。所以通常是不能在这样环境下的handler里写IO阻塞的代码。</p>

<p>解决这个问题，一种方式是多线程，一种是全异步化。后者最典型的例子就是nodejs，坦白说编程模型非常复杂，对开发者要求较高。一种相对简单的办法，就是以多线程的方式，增加CPU的利用效率，来平衡IO阻塞带来的影响。IO等待时间的比重越大，线程数就可以陪得越高。牺牲一些sy的CPU时间，换取更高的利用率。</p>

<p>但是随之而来了另一个问题，因为在handler中使用了多线程的模型。对顺序收到的包，交由不同的线程并行处理，就没有办法保证返回时的顺序。客户端就无法了解刚刚返回的包是对应哪个请求的。</p>

<p>这个情况也有两种办法处理。其一是在线程管理上做文章，采用一种折中的办法。对于每一个客户端连接来说，仍然是占用同一个线程来处理。这样首先任务不会占用worker线程，其次在整体上仍然提高了CPU的利用率。但是这样做的缺点是，在单一客户端看来，任务仍然是串行执行: 三个需要耗时500ms的请求同时顺序发出，第三个至少要在1500ms之后才能收到响应，客户端的latency比较高。</p>

<p>另一种，就是在应用协议层面做一个冗余字段，通常叫做serial id或者transaction id。客户端为每一个请求生成一个这样的id，并存储这个id对应的回调。服务器端不需要对包的顺序作任何关注，只需要把这个id原封不动地拷贝回去即可。这样，服务器就可以自由调度线程来处理请求。以上面的例子，在不繁忙的情况下，三个响应在500ms左右就都可以到达了。</p>

<p>这种方式对应用协议有特殊的要求，但是比较常见的协议都预留了这个字段，Diameter协议甚至留了两个这样的字段来便于代理的实现。</p>

<p>slacker 0.7.x基于aleph，由于aleph / lamina无法侵入协议层面，所以采用的都是顺序的客户端和服务器。这种方式编程非常简洁，协议设计简单，实现起来很快。但是作为RPC框架，一旦客户的函数阻塞较长，就会影响整体性能。0.8.0开始，通过新的协议和link库支持，slacker采用了transaction id的方式，服务器端默认使用并行处理，客户端不再依赖顺序指定响应和回调。尽管在一些CPU为局限的测试里性能有少许下降(与单线程相比，增加了调度的成本)，但是针对实际应用里IO等待较多的情况，新版本应该会表现出更好的综合性能。</p>

<p>以上这些，就是最近的心得，希望能解释清楚事件驱动服务器里的这些事情。</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Slacker Performance Enhanced</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2012/04/02/slacker-performance-enhanced/"/>
    
    <id>/blog/2012/04/02/slacker-performance-enhanced</id>
    <published>2012-04-02T00:00:00+08:00</published>
    <updated>2012-04-02T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>In the slacker framework, performance issue becomes more and more critical as the basic features are almost completed. As mentioned in cnclojure meetup, I will focus on the performance enhancement in next release. </p>

<p>Now I have worked out a testable version. The new slacker core has been moved to a new NIO library, <a href="https://github.com/sunng87/link" target="_blank">link</a>. Compared with aleph, link is a thin wrapper of Netty. It takes some nice features from aleph (gloss codec dsl, elegant API), and drops the heavy abstraction, lamina. The new slacker client runs on a real nonblocking connection. Connection pooling is no longer needed.</p>

<p>I have some performance benchmark to visualize the improvement. The test was made on my laptop (Intel(R) Core(TM)2 Duo CPU     T5870  @ 2.00GHz). It ran 400,000 calls with 40 threads on a local slacker server.</p>

<p>slacker 0.7.0 (clojure 1.2, aleph 0.2.0): <strong>614005.059259msecs</strong>
slacker 0.7.1-SNAPSHOT (clojure 1.3, aleph 0.2.1-beta2): <strong>409110.909142msecs</strong>
slacker 0.8.0-SNAPSHOT (clojure 1.3, link 0.2.0-SNAPSHOT): <strong>42468.401522msecs</strong></p>

<p><img src="http://i.imgur.com/gMtdo.jpg" alt="tps chart" /></p>

<p>Check out the new slacker on the <a href="https://github.com/sunng87/slacker/tree/0.8-dev" target="_blank">0.8-dev</a> branch. </p>

<p></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Slacker Slides on Cnclojure Meetup</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2012/03/06/slacker-slides-on-cnclojure-meetup/"/>
    
    <id>/blog/2012/03/06/slacker-slides-on-cnclojure-meetup</id>
    <published>2012-03-06T00:00:00+08:00</published>
    <updated>2012-03-06T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>从北京回来两天了，稍微有点累，还没来得及总结一下，先把slides上传分享一下： <a href="http://www.box.com/s/k0alcj1p115jq40bdkik" target="_blank">http://www.box.com/s/k0alcj1p115jq40bdkik</a></p>

<p>解压之后 lein deps && lein run 一下即可。</p>

<p>这是一个借助impress.js制作的幻灯片。之所以让它跑在webbit里，是因为我简单hack了impress.js让你可以通过websocket远程控制幻灯片播放。这样，就可以通过手机上的firefox浏览器（目前android上仅有firefox支持websocket）控制播放，把手机变成一款遥控器。</p>

<p></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Dosync+: Dosync With Event Listener</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2012/02/24/dosync-dosync-with-event-listener/"/>
    
    <id>/blog/2012/02/24/dosync-dosync-with-event-listener</id>
    <published>2012-02-24T00:00:00+08:00</published>
    <updated>2012-02-24T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>Discussed in clojure-cn mailing list, we come up with an extensible dosync block with event listener: on-start, on-retry and on-committed.</p>

<p><script src="https://gist.github.com/1898383.js?file=dosync-plus.clj"></script></p>

<p>With these extension points, you can bind STM monitor to a transaction. And I believe there will more advanced use cases on this.</p>

<p><script src="https://gist.github.com/1898383.js?file=main.clj"></script></p>

<p></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">使用Enlive作为模板引擎</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/12/29/%E4%BD%BF%E7%94%A8enlive%E4%BD%9C%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
    <id>/blog/2011/12/29/使用enlive作为模板引擎</id>
    <published>2011-12-29T00:00:00+08:00</published>
    <updated>2011-12-29T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>在所有的clojure web开发例子里，对模板的介绍都很少。很多的简单例子都是以hiccup作为页面生成的手段。hiccup是个clojure的html DSL，例子里用这样的DSL生成页面确实很酷，可是他是real world吗，当然不是。</p>

<p>好在clojure世界里早就有了enlive，它不仅是一个通过css selector解析html的库，本身也可以作为模板引擎应用在web开发中。我不知道这种通过css selector的方式是否是enlive首创，不过他实在是非常新颖独特，而且平滑了页面设计和程序的集成。</p>

<p>例如这样一个模板 index.html：<br />
[cc lang="html"]
<div id="cc">Sample Text</div>
[/cc]</p>

<p>在clojure程序中，使用enlive的deftemplate<br />
[cc lang="clojure"]<br />
(deftemplate index "index.html"<br />
  [ctx]<br />
  [:div#cc] (content (:data ctx)))<br />
[/cc]</p>

<p>在控制器里，可以很MVC地渲染页面<br />
[cc lang="clojure"]<br />
(index {:data "rendered text"})<br />
[/cc]</p>

<p>除了content用于渲染文本，还有html-content可以渲染含html标签的内容，以及set-attr用来修改页面元素的属性。</p>

<p>和传统的模板引擎相比，最大的不同是enlive里没有嵌入模板的直观的控制流，没有循环和条件判断，但是并非不可实现。</p>

<p>循环输出一组list</p>

<p>页面 list.html<br />
[cc lang="html"]
<ul id="the-list">
<li class="list-item"></li>
</ul>
[/cc]</p>

<p>定义一个enlive的snippet<br />
[cc lang="clojure"]<br />
(defsnippet item-model "page.html" [:.list-item]<br />
  [ctx]<br />
  [:.list-item] (content (:data ctx)))<br />
[/cc]</p>

<p>在页面模板里<br />
[cc lang="clojure"]<br />
(deftemplate list-page "list.html"<br />
  [ctx]<br />
  [:ul#the-list] (content (map item-model (:some-list ctx))))<br />
[/cc]</p>

<p>这样在页面里列表项会被循环输出，而在页面设计时这里可以放任意个li，并且直接交给后台作为模板。</p>

<p>条件判断</p>

<p>页面，设计时显示所有的内容 msg.html<br />
[cc lang="html"]
<span id="msg">只在一定条件下显示</span>
[/cc]</p>

<p>在模板中通过clojure的if进行判断<br />
[cc lang="clojure"]<br />
(deftemplate msg "msg.html"<br />
  [ctx]<br />
  [:span#msg] (if (:show ctx) identity (html-content "")))<br />
[/cc]</p>

<p>解决了这两个问题，基本上用enlive作为模板引擎就没有障碍了。不过enlive也有一点小问题，其一可能是性能的问题，方便的selector显然要比传统的模板语言消耗更多的CPU。另外，在开发过程里，页面文件在服务器启动后不能热加载，修改页面必须重启ring才能看到。也许有时间的话，可以给它加一个reload选项。</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">使用Clojure Thread Macro的心得</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/12/16/%E4%BD%BF%E7%94%A8clojure-thread-macro%E7%9A%84%E5%BF%83%E5%BE%97/"/>
    
    <id>/blog/2011/12/16/使用clojure-thread-macro的心得</id>
    <published>2011-12-16T00:00:00+08:00</published>
    <updated>2011-12-16T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>Thread Macro是clojure里一个很强大的宏，他帮助你简化嵌套函数的调用，比如<br />
[cc lang="clojure"]<br />
(str (inc (count [:a :b])))<br />
[/cc]<br />
就可以利用thread macro简写成<br />
[cc lang="clojure"]<br />
(-> [:a :b] count inc str)<br />
[/cc]</p>

<p>-&gt;&gt;和-&gt;类似，区别在于-&gt;&gt;把值作为函数的最后一个参数传入。</p>

<p>简单的功能介绍完了，接下来就遇到问题了。我需要功能，能够接受一个或多个函数，然后把这些函数组成一个pipeline。这时很自然想到-&gt;是一个好帮手。也许只需要一个类似这样的form就可以了： #(apply -&gt; % [funcs])。结果失败了，因为-&gt;是个宏，所以根本不能用apply。于是想到有apply-macro吗？有，或者说曾经有过。在contrib中曾经有一个apply-macro，不过被强烈不推荐使用。到这里，这条路堵死了，惟一的办法就是把-&gt;放到API之外，放到用户代码里去。</p>

<p>放到用户代码里，你需要写一个详细的说明文档并且告诉用户他必须这么做。然而在clojure世界里有一个更好的办法就是再写一个宏把-&gt;包装起来。这么做看似多此一举，其实是保持了API的一致性。通过宏，我们可以把自己的API延伸到用户代码中去。或者说，通过一个类似DSL的宏，给一些并不优雅的API一个缓冲，也为API日后的演化留下空间。</p>

<p>这里还要扯开一句关于宏的开发。clojure中所谓code is data，主要就是体现在宏里。原本在多数其他语言里，宏是不能求值的。但是在clojure里，由于code is data的缘故，宏是可以求值的。所有的输入数据都是list，你可以做first/reverse这样的操作。但是有一点要注意的是，宏中求得的值和代码里的值是不一样的。例如{:a inc}这样一个字面量，在宏里是可以通过:a做求值的，然后这里得到的并非一个函数（function），而是一个符号（symbol）。再者，调试宏的时候你可能会被这样的结果困惑：<br />
[cc lang="clojure"]<br />
(defmacro a [f] (println (:a f)))<br />
(a {:a 1}) ; ==> prints 1<br />
(def b {:a 1})<br />
(a b) ; ==> prints nil<br />
[/cc]<br />
字面量可以，同值的变量就不行了。原因还是那句，宏里不能求值。</p>

<p>继续谈-&gt;。这个宏其实远没有你想象的那么驯服。遇到复杂一点的情况：<br />
[cc lang="clojure"]<br />
(def m {:a inc})<br />
(-> 2 (get m :a) str)<br />
[/cc]<br />
这个写法对吗？str是个函数，(get m :a)返回的是inc也是个函数，貌似正确。运行之后却报错get的参数数量错误。所以千万不要忘了-&gt;是个宏，(get m :a)这里是不会求值到inc的，直接作为一个list被宏吞下去。在宏里只能通过符号的组合变化来生成代码，那么一不小心，就没有inc什么事了。</p>

<p>于是，你可能想到这里需要一个确切的函数，就好比这样：<br />
[cc lang="clojure"]<br />
(def m {:a inc})<br />
(-> 2 (fn [x] ((get m :a) x)))<br />
[/cc]<br />
也许这样就好多了，我们放了一个匿名函数，并不要求宏去求值，因为这个匿名函数会被宏生成到新的代码里。里面的get也会在运行时求值。看似没什么问题，可是一运行还是没有期待的结果，居然返回了一个匿名函数！而对这个匿名函数求值得到的也是一个错误的结果！简直有点无厘头了。</p>

<p>呵呵，不故弄玄虚了。我们用macroexpand看看发生了什么。</p>

<p>这是用匿名函数包装以前<br />
[cc lang="clojure"]<br />
(macroexpand-1 '(-> 2 (get m :a)))<br />
(get 2 m :a)<br />
[/cc]<br />
-&gt;居然只是简单地把2放到了get这个form里面！</p>

<p>再看看用匿名函数包装后的结果<br />
[cc lang="clojure"]<br />
(macroexpand-1 '(-> 2 (fn [x] ((get m :a) x))))<br />
(fn 2 [x] ((get m :a) x))<br />
[/cc]<br />
和刚才一样，2被放到了第一个form的第一个参数位置！得到的是一个非法的form。</p>

<p>那么既然-&gt;只是简单地把第一个参数放到后面form的首个参数的位置，那么这个宏正确的使用方法其实是<br />
[cc lang="clojure"]<br />
(def m {:a inc})<br />
(-> 2 ((fn [x] ((get m :a) x))))<br />
[/cc]<br />
再加一层括号！<br />
[cc lang="clojure"]<br />
(macroexpand-1 '(-> 2 ((fn [x] ((get m :a) x)))))<br />
((fn [x] ((get m :a) x)) 2)<br />
[/cc]</p>

<p>可见，-&gt;虽然是个功能强大的宏，但宏终归只是宏，和函数的区别是明显的。在使用的时候，不能完全按照函数的习惯。</p>

<p>如果你想了解实际的代码，可以参考slacker 0.3.0里的这个interceptor框架：
<a href="https://github.com/sunng87/slacker/blob/master/src/slacker/interceptor.clj" target="_blank">https://github.com/sunng87/slacker/blob/master/src/slacker/interceptor.clj</a>
上面提到的难处，多半也都是在开发这个框架时亲身经历的。</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Clojure RPC, Prototyping and Early Thoughts</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/11/27/clojure-rpc-prototyping-and-early-thoughts/"/>
    
    <id>/blog/2011/11/27/clojure-rpc-prototyping-and-early-thoughts</id>
    <published>2011-11-27T00:00:00+08:00</published>
    <updated>2011-11-27T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>Last week, I prototyped an RPC framework, <a href="https://github.com/sunng87/slacker" target="_blank">slacker</a>, by clojure and for clojure. </p>

<p><h3>What I did ?</h3>
Suppose you have a sets of clojure functions to expose. Define them under a namespace:<br />
[cc lang="clojure"]<br />
(ns slapi)<br />
(defn timestamp []<br />
  (System/currentTimeMillis))</p>

<p>;; ...more functions<br />
[/cc]</p>

<p>Expose the namespace with slacker server, on port 2104:<br />
[cc lang="clojure"]<br />
(use 'slacker.server)<br />
(start-slacker-server (the-ns 'slapi) 2104)[/cc]</p>

<p>On the client side, we use the `defremote` macro to create a facade for `timestamp` function. This API will keep the client code consistent with local mode.<br />
[cc lang="clojure"]<br />
(use 'slacker.client)<br />
(def sc (slackerc "localhost" 2104))<br />
(defremote sc timestamp)<br />
(timestamp)<br />
[/cc]</p>

<p>Internally, slacker uses <a href="https://github.com/ztellman/aleph" target="_blank">aleph</a> for transport and <a href="https://github.com/revelytix/carbonite" target="_blank">carbonite</a> for serialization. I forked carbonite and made it compatible with clojure 1.2 because the aleph mainline is still running on 1.2. </p>

<p><h3>Going further</h3>
<h4>High-Order Functions</h4>
In clojure, functions are treated as first class value. Within memory, you can pass function as parameter to another function. However, this is not supported by serialization framework. So is it possible to add support for that in future?</p>

<p><h4>Lazy sequence as parameter</h4>
This is another interesting feature in clojure function call. You can pass a lazy-sequence to clojure function. In RPC, it requires parameters to be evaluated on the server side.<br />
[cc lang="clojure"]<br />
(defn get-first [& args] (first args))<br />
(apply get-first (range))<br />
[/cc]<br />
Example copied from <a href="http://stackoverflow.com/q/8205446/371141" target="_blank">StackOverflow</a></p>

<p><h4>Coordinated states between several remote servers</h4>
With RPC, we can update states on several servers. So do we need something like distributed dosync:<br />
[cc lang="clojure"]<br />
(defremote a1 update-a1-state)<br />
(defremote a2 update-a2-state)<br />
(dosync-distributed<br />
  (update-a1-state some-value)<br />
  (update-a2-state some-value))<br />
[/cc]<br />
I'm not sure if this is a valid scenario in real world but I think it's an interesting topic.(distributed STM?)</p>

<p><h3>Conclusion</h3>
RPC is the first step to distributed clojure world. I will keep you updated with my prototype. 
</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Spark in Common Lisp</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/11/19/spark-in-common-lisp/"/>
    
    <id>/blog/2011/11/19/spark-in-common-lisp</id>
    <published>2011-11-19T00:00:00+08:00</published>
    <updated>2011-11-19T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>还是关于spark的，一石激起千层浪，每个人心中都有一个spark。其实spark脚本刚出来的时候问题很多，但是就是因为产生了共鸣，众人拾柴pull request多。像redis的作者antirez也忍不住自己用c写了一个<a href="https://github.com/antirez/aspark" target="_blank">aspark</a>。</p>

<p>说完了别人的，那么来看看我的：clspark，common-lisp的spark。原本是打算用clojure写，但是想到jvm的启动速度，把这个机会留给我的第一个common lisp程序吧。</p>

<p><img src="http://i.imgur.com/oD7m4.png" alt="" /></p>

<p>其实很简单。
<script src="https://gist.github.com/1375401.js"> </script></p>

<p>common lisp的核心库里没有split，所以这里从cl-cookbook拷贝了一个split的实现，坦白说我还看不太懂这个loop的写法。loop是common lisp中最尴尬的form，因为他的形式太多。这点在clojure中是不存在的。比较一下就能发现，在语言层面，clojure是相对现代得多的lisp方言。
</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Grails的核心依赖必须保证项目中版本一致！</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/10/15/grails%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BE%9D%E8%B5%96%E5%BF%85%E9%A1%BB%E4%BF%9D%E8%AF%81%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%89%88%E6%9C%AC%E4%B8%80%E8%87%B4%EF%BC%81/"/>
    
    <id>/blog/2011/10/15/grails的核心依赖必须保证项目中版本一致！</id>
    <published>2011-10-15T00:00:00+08:00</published>
    <updated>2011-10-15T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>好久没写语录式大标题了，实在是今天玩Grails受害很深很深。</p>

<p>Grails因为本身是通过ivy来管理依赖的，虽然后续的版本和maven的集成不断加深，但是本身还是通过ivy来解析pom.xml。也就是说最后的活还是ivy干的。如果你的项目比较大，选择了通过maven来管理项目，而你的依赖中又牵扯了很多其他的依赖，那么你危险了。</p>

<p><blockquote>:: UNRESOLVED DEPENDENCIES ::</blockquote></p>

<p>:: log4j#log4j;1.2.16: configuration not found in log4j#log4j;1.2.16: 'master'. It was required from ...;1.7.0 runtime</p>

<p>对maven用户这是一条多么发指的报错！（比如<a href="http://forum.springsource.org/showthread.php?104033-Can-not-load-a-log4J-library" target="_blank">这个</a>）</p>

<p>它的原因其实是你的dependency中有!=1.2.16版本你的log4j，比如1.2.12，即使你在pom里将它添加到了exclusion中也没有用，必须要保持版本的一致！至于你用什么办法让他们保持一致，还是干脆放弃用maven管理你的grails项目：It's up to you.</p>

<p>同样的问题还出现在其他核心依赖上，例如commons-pool。
</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">The Distribution of Intelligence</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/10/10/the-distribution-of-intelligence/"/>
    
    <id>/blog/2011/10/10/the-distribution-of-intelligence</id>
    <published>2011-10-10T00:00:00+08:00</published>
    <updated>2011-10-10T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>This could be a big title for the content.</p>

<p>I just work out a heat map based on <a href="http://maps.google.com/maps/ms?ie=UTF&msa=0&msid=203716810039202316490.0004aeb1b1a01b1d3b9af" target="_blank">the data</a> of users who enrolled online courses offered by Stanford.</p>

<p><a href="http://imgur.com/rWUkH"><img src="http://i.imgur.com/rWUkH.png" width="500" alt="" title="Hosted by imgur.com" /></a>
(Click to enlarge)</p>

<p>I think you already have your ideas about this map. New England, California and Central Europe has higher density than any other area of the world. Also you can find some light in South America, East Coast Australia, India and China. I think this could be an overview of how intelligence distributed around the globe.
</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">GPS数据采集与OpenStreetMap编辑</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/10/05/gps%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E4%B8%8Eopenstreetmap%E7%BC%96%E8%BE%91/"/>
    
    <id>/blog/2011/10/05/gps数据采集与openstreetmap编辑</id>
    <published>2011-10-05T00:00:00+08:00</published>
    <updated>2011-10-05T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>简单介绍一下通过GPS采集道路数据并上传到OpenStreetMap的流程。</p>

<p><h3>采集</h3>
首先你需要一个GPS数据记录器，或者叫做GPS Logger。这类产品在淘宝上可以找到很多，台湾的长天(HOLUX)是相对价廉物美的品牌。我的设备是HOLUX m1000c，下文以此为例。</p>

<p>m1000c的使用非常简单。开机之后，指示GPS的黄灯点亮，设备开始搜索GPS卫星。根据你所出的位置、遮挡情况以及天气情况，搜星的时间略有不同。当GPS黄灯开始闪烁时Logger即开始记录数据，默认情况下m1000c每隔5秒记录一次数据。每次重启后，Logger都会新开一条记录。</p>

<p><h3>导入</h3>
对Windows用户，将Logger通过USB线与电脑连接后，可以利用随机附带的软件将数据导入为GPX格式。对Linux用户，可以利用<a href="http://www.gpsbabel.org/" target="_blank">gpsbabel</a>导入数据：
<em>gpsbabel -t -i m241 -f /dev/ttyACM0 -o gpx -F myfile.gpx</em></p>

<p>其中：
<ul>
	<li>-t 表示数据为track类型</li>
	<li>-i m241 输入格式为HOLUX m241，m1000c使用的是这种格式</li>
	<li>-f /dev/ttyACM0 输入设备是/dev/ttyACM0</li>
	<li>-o gpx 输出格式是gpx</li>
	<li>-F 输出文件myfile.gpx</li>
</ul></p>

<p>在一些发行版上，需要root权限访问/dev/ttyACM0，所以不要忘记将输出的文件chown给普通用户。</p>

<p>导入完成后可以利用下面的命令清空Logger
<em>gpsbabel -i m241,erase_only=1 -f /dev/ttyACM0</em></p>

<p>在Windows和Linux上都可以使用<a href="http://sourceforge.net/apps/mediawiki/viking/index.php?title=Main_Page" target="_blank">Viking</a>查看导入的数据：
<ul>
	<li>启动viking</li>
	<li>添加一个OSM地图图层： Layers->New Map Layer</li>
	<li>导入GPX数据： File->Append File...</li>
	<li>下载OSM地图，右键点击左侧的Map图层，Download Missing Onscreen Maps</li>
</ul></p>

<p><a href="http://www.flickr.com/photos/40741608@N08/6213079184/" title="Screenshot at 2011-10-05 09:45:20 by 贝小塔, on Flickr"><img src="http://farm7.static.flickr.com/6103/6213079184_f653ca2ca6.jpg" width="500" height="387" alt="Screenshot at 2011-10-05 09:45:20" /></a></p>

<p><h3>编辑</h3>
Windows和Linux用户都可以通过<a href="http://merkaartor.be/" target="_blank">Merkaartor</a>编辑OSM数据。</p>

<p>启动Merkaartor，导入GPS数据： File->Import。<br />
选择左侧的GPS图层，对需要导入的数据，右键点击Extract Drawing Layer将GPS转换为可编辑数据。
<a href="http://www.flickr.com/photos/40741608@N08/6213247680/" title="Screenshot at 2011-10-05 10:57:17 by 贝小塔, on Flickr"><img src="http://farm7.static.flickr.com/6167/6213247680_046e360c63.jpg" width="500" height="303" alt="Screenshot at 2011-10-05 10:57:17" /></a></p>

<p>根据实际情况编辑道路数据的属性。对GPS转换的数据，选择菜单Feature->Force Upload，将其加入dirty set准备上传。点击Upload即可将数据上传到OpenStreetMap。</p>

<p></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Using Google Closure Library With ClojureScript</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/08/05/using-google-closure-library-with-clojurescript/"/>
    
    <id>/blog/2011/08/05/using-google-closure-library-with-clojurescript</id>
    <published>2011-08-05T00:00:00+08:00</published>
    <updated>2011-08-05T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>Google closure library is shipped with ClojureScript, and could be compiled with ClojureScript into a minimized javascript file. So closure library is doubtlessly the first candidate when you are considering to use an external Javascript library in your cljs browser application.</p>

<p>However, different from clojure's interoperability with Java, ClojureScript has its own characteristics when you are interoperating with JavaScript and JavaScript based libraries.</p>

<p><strong>Clojure types are not fully compatible with JavaScript types</strong>
In ClojureScript, you can never treat a Clojure map as a JavaScript object although they have similar characteristics. You have to do some conversion before passing a clojure map to javascript functions. Matthew Gilliard made <a href="https://gist.github.com/1098417#file_ajax.cljs" target="_blank">a sample</a> of such conversion.</p>

<p><strong>JavaScript package is not Clojure namespace</strong>
This could be a common mistake for ClojureScript newbie. Actually, JavaScript doesn't have concept of "Package" or "Namespace". Many JavaScript libraries(dojo, Google Closure) made enhancement on this. ClojureScript also takes advantage of this mechanism. So before you start to coding with closure, you may browse <a href="http://closure-library.googlecode.com/svn/docs/index.html" target="_blank">closure library API document</a>, and find a module called <em>goog.net</em> which includes lots of types. Then you write this:<br />
[cc lang="clojure"]<br />
(ns myjs<br />
  (:require [goog.net :as gnet]))<br />
[/cc]</p>

<p>But compiler shows you "ERROR: JSC_MISSING_PROVIDE_ERROR. required "goog.net" namespace never<br />
provided at ... ". This is not a PATH issue. The root cause is that closure module has a lower granularity than Clojure ones. Types are often contained in their own modules. You can find closure source code in <em>clojurescript/closure/library/closure</em>. Modules are declare with <em>goog.provide</em> function. Thus, you should require this name instead of the logical module name.<br />
[cc lang="clojure"]<br />
(ns myjs<br />
  (:require [goog.net.XhrIo :as gxhr]))<br />
[/cc]</p>

<p>In addition, ClojureScript does not support 'use'.</p>

<p><strong>Just use full name for JavaScript class</strong>
For functions contains in some module, you can refer it with the clojure way:<br />
[cc lang="clojure"]<br />
(ns myjs<br />
  (:require [goog.dom :as dom]))<br />
(dom/$ "element-id")<br />
[/cc]</p>

<p>But for classes, just use the full name and ignore the module alias.<br />
[cc lang="clojure"]<br />
(ns myjs<br />
  (:require [goog.net.XhrIo :as gxhr]))<br />
(def xhr (goog.net.XhrIo.))<br />
[/cc]</p>

<p>These are basic tips before you start using Closure with ClojureScript. Leveraging on Google's closure library, you can create cross-browser JavaScript application with Clojure easily.</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">ClojureScript Recipes</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/07/24/clojurescript-recipes/"/>
    
    <id>/blog/2011/07/24/clojurescript-recipes</id>
    <published>2011-07-24T00:00:00+08:00</published>
    <updated>2011-07-24T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>一周前左右有人说javascript是assembly language for the web, 结果一周不到clojurescript发布了。闹了半天clojure 1.3迟迟不发布是因为effort都迫不及待地转移到向javascript迁移上去了。简单地说cljs是clojure在javascript上的实现，通过cljsc可以把clojure编译成js，运行在浏览器里或是Node环境里。</p>

<p>目前clojurescript还没有正式的发布版本，需要从github签出开发版本。
<ol>
	<li>cljs是在Oracle JDK上开发的，引用了sun.org.mozilla.javascript.internal.Context，这个类在OpenJDK里叫做sun.org.mozilla.javascript.Context。所以没有办法，暂时只能在Oracle JDK上用clojurescript。</li>
	<li>cljs自带的所有脚本，启动jvm时，heap size都是开2G的。可怜我所有的内存才2.5G，还是分布在两台电脑上（#@&amp;*……@￥@！）。不过我手动把它改为512M后cljsc还是依然可以正常运行的。</li>
	<li>cljs与javascript的互操作是最麻烦的部分，一般情况cljs通过(js*)这个form来访问javascript数据和对象，比如访问document：(js* "document")。进而访问getElementById时，即(.getElementById (js* "document") "some-id")。</li>
	<li>cljs访问js对象时，通过(aget)而不是(.属性名)，例如(aget rage "ups")编译后为rage.ups，如果(.ups rage)就会被当作函数调用。不过奇怪的是如果(.title rage)依然会被编译成rage.title。这种不一致的情况在对.url也存在。当然用aget是可以获得一致的结果的（aget在clojure里是根据索引取java数组的form，在cljs里可以支持js object了）。</li>
	<li>当访问无参数的js对象时，cljs与clojure有不同。例如在clojure里(.toString date)，而在cljs里，这样写编译的结果是date.toString，注意没有括号，直接访问这个function对象了。所以在cljs里，正确的写法有些变化(. date (toString))。</li>
	<li>创建js对象，可以通过(js-obj)这个form</li>
	<li>修改dom属性，需要用(set!)这个form，如 (set! (.src img) "http://xxx")。如果把cljs用在网页里，类似这样的操作比比皆是，这和clojure大不相同。</li>
	<li>cljs里没有STM，暂时也不支持ref。可以直接用def定义变量，随意地访问和修改，js环境是单线程环境。</li>
	<li>对于要对外访问的方法，在声明时加上^:export可以让编译器不修改方法的名字。</li>
</ol>
用cljs开发有趣归有趣，调试还是很困难的，建议开发的时候就写好打log的代码(js* "console.log")，因为目前cljsc编译的速度也不快，反复地修改代价还是挺高的。当然，为了cool，以上都不是问题。</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">使用defrecord与defprotocol的注意事项</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/07/22/%E4%BD%BF%E7%94%A8defrecord%E4%B8%8Edefprotocol%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    
    <id>/blog/2011/07/22/使用defrecord与defprotocol的注意事项</id>
    <published>2011-07-22T00:00:00+08:00</published>
    <updated>2011-07-22T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>简单地说，protocol是clojure中的接口，record是clojure中的数据类型。</p>

<p>可以通过这样的code定义一个protocol<br />
[cc lang="clojure"]<br />
(defprotoco DummyProtocol<br />
  "doc string..."<br />
  (method-one [self x] "doc string..."))<br />
[/cc]</p>

<p>需要注意的是，protocol里所有方法的第一个参数都是self/this参数（类似python），从第二个开始才是调用时传入的参数。如果方法要重载呢？</p>

<p>[cc lang="clojure"]<br />
(defprotocol DummyProtocol<br />
  "doc string..."<br />
  (method-one [self x] [self x y] "doc string")<br />
)
[/cc]</p>

<p>Apress的 Practical Clojure 书里的例子，给重载的参数表加上了括号，这样会导致编译错误（<a href="http://book.douban.com/annotation/13819191/" target="_blank">注记</a>）。</p>

<p>定义一个record实现protocol</p>

<p>[cc lang＝"clojure"]<br />
(defrecord DummyRecord [a b c]<br />
  DummyProtocol<br />
  (method-one [self x] (+ a x))<br />
  (method-one [self x y] (+ a x y)))<br />
[/cc]<br />
Practical Clojure里关于这部分的代码，又丢掉了self参数（<a href="http://book.douban.com/annotation/13819264/" target="_blank">注记</a>）。</p>

<p>最后还有一个问题，如果直接use你的ns，你会发现调用record时出现：<br />
java.lang.IllegalArgumentException: Unable to resolve classname: DummyRecord</p>

<p>怎么回事，不是都use了吗？原因是record被编译成了java对象，所以引用时要用java对象的引用方式，import之。</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Staged Event-Driven Architecture</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/07/13/staged-event-driven-architecture/"/>
    
    <id>/blog/2011/07/13/staged-event-driven-architecture</id>
    <published>2011-07-13T00:00:00+08:00</published>
    <updated>2011-07-13T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>按照传统的编写应用程序的思路，当server接到请求，包装完成之后，分配到线程池中交给一个线程完成，返回。Java的servlet容器就是这么设计的，这么多年大部分的应用程序也是在这种模式下编写的。当任务的代价比较大，比如多次和数据库交互，并且可能和后端其他服务通信，这是线程被任务占用的时间就相对较长。如果请求的并发量很大，容器的线程池耗尽，新的请求就无法被处理，导致并发性无法提高，吞吐量也无法提高。</p>

<p>实际上在大部分应用程序里，所谓代价很高的任务，往往都是I/O Bound。涉及网络通信，磁盘读写，线程被迫wait，CPU却是空闲的。所以，I/O Bound的程序理论上都还有优化的空间。于是有了这种Staged Event-Driven Architecture，即SEDA。</p>

<p>SEDA的思路是将原先由一个线程完成的任务，分割为相对独立的多个阶段。每个阶段由专用的一组线程负责执行，阶段之间用过队列交互。又是上次提到的老话：If you cannot split it, you cannot scale it.</p>

<p>例如，我们的业务逻辑是读取请求，操作数据库，与后端通信，操作数据库，写回结果。如果采用NIO的方式，网络通信可以认为是非阻塞的。而目前与数据库的交互，通常还是阻塞式的风格。这样这五个阶段分别是非阻塞、阻塞、非阻塞、阻塞、非阻塞。组塞操作容易成为性能瓶颈，CPU时间用于等待，占用率不高，所以对组塞操作可以分配相对多的线程；非阻塞操作速度较快，为了避免快速的切换导致sy升高，采用和CPU核数一样多的线程即可。</p>

<p>这样，原本一个线程反复等待的阻塞操作，变成了部分线程等待的同时，其他线程仍然在处理自己的业务，有效使用CPU。利用的多核的优势，提高了CPU的占用，即提高了系统的处理能力。</p>

<p>而对外部接口来说，当读取数据的线程在读取完毕之后，将任务dispatch到相应队列即返回，前端可以保证很高的处理速度，并发性也可以保证。任务被积压在阻塞操作的队列中，而消费阻塞操作的线程要多于提供者，在一定程度上也保证了处理速度。再退一步说，当阻塞操作的速度却是无法消费大量任务时，前端可以根据队列的大小判断当前系统的load，拒绝服务。</p>

<p>当然，采用这种方式，只有在并发量提高到一定程度，并发成为系统瓶颈时才能体现价值。就单个操作而言，由于队列的传递，他的latency一定是有所上升的。</p>

<p>关于SEDA，可以参考<a href="http://matt-welsh.blogspot.com/">Matt Welsh</a>的相关论文：The Staged Event-Driven Architecture for Highly-Concurrent Server Applications。</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Failure Detection</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/07/03/failure-detection/"/>
    
    <id>/blog/2011/07/03/failure-detection</id>
    <published>2011-07-03T00:00:00+08:00</published>
    <updated>2011-07-03T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>分布式系统中检测节点的工作情况，最直观的方法是采用心跳包的方式，通过定时发送心跳包，如果对端节点没有正常返回，则认为此节点处在failure状态，这时系统需要采取一定的措施来保证正常运行。目前，Zookeeper就是采用这种方式（org.apache.zookeeper.ClientCnxn）。</p>

<p>但是为了避免由于网络抖动等等意外因素导致的误报，通常在心跳包的基础上做一些改进。我在盛大做服务的路由代理时，代理和后端的服务通过心跳包保持连接。当心跳包出现异常，或服务调用出现异常（类似HTTP 500的系统异常），代理会记录当时的时间戳。根据配置，代理会存储最近50次的时间戳，并且检查他们的方差，当方差小于一个阈值时，就认定服务为failure状态，将服务从列表中剔除并发送报警。在一些测试里，这套机制是可以按照预期工作的。可惜这个系统最后没有上生产系统，所以也没有实际的运维经验。</p>

<p>最近看到了Cassandra使用的Failure Detection机制，叫做Phi Failure Detection Model。这个思路在一定程度上跟我的方式类似，在Cassandra的实现里，他会存储最近1000次失败的信息（org.apache.cassandra.gms.FailureDetector#sampleSize_）。此外，Cassandra存储的是失败的间隔，而不是绝对的时间戳（首次失败，存储的是心跳间隔的二分之一）。判断失败的φ值是通过这个公式就算：
<font face="monospace">φ = (now - last_failure) * lnE / mean(interval_samples)</font>
当φ值大于配置的threshold时，Cassandra的Gossip机制认为这个节点为failure。默认的配置里，这个threshold值为8. 关于Phi Failure Detection Model，可以参考论文：Information Propagation on the Phi Failure Detector</p>

<p>而为了提高Zookeeper的Failure Detection的质量，去年的<a href="https://issues.apache.org/jira/browse/ZOOKEEPER-702">一个Google Summer of Code项目</a>为Zookeeper引入了一些流行的检测模型，包括前面提到的Phi Failure Detector，以及Bertier的方法和Chen的方法。</p>

<p>Chen方法以一个固定的alpha常数，加平均到达时间作为估计的timeout值。</p>

<p>在Bertier方法中，用于判断心跳包失败的timeout时间通过三个参数gamma/beta/phi被动态修正：
<font face="monospace">error = now -ea - delay;</font> （收到心跳包的时间-估计的心跳包到达时间-估计的延迟）
<font face="monospace">delay = delay + gamma * error;</font> （根据gamma和error修正延迟）
<font face="monospace">var = var + gamma*(abs(error) - var);</font> （error值的variation，即<font face="monospace">var<sub>n</sub>=Σ g(1-g)<sup>n-i</sup>*e<sub>i</sub></font>）
<font face="monospace">ea = now + avg(‌interval);</font> （根据心跳包的平均间隔修正估计时间）
<font face="monospace">timeout = avg(interval) + beta*delay + phi*var</font> (计算新的timeout)<br />
假如心跳包在timeout后到达，timeout还需要在上面的基础上加上常数moderationStep。</p>

<p>GSoC项目里，gamma/beta/phi/moderationStep的默认值分别为0.1/1.0/4.0/500。Bertier方法的timeout值根据网络情况自适应。</p>

<p>评价一种Failure Detector的标准，包括它发现failure节点的时间和误报率。<a href="http://wiki.apache.org/hadoop/ZooKeeper/GSoCFailureDetector#Experimentation">这里</a>有GSoC项目中作者进行的实验及结论，可供参考。</p>

<p><div class="zemanta-pixie"><img class="zemanta-pixie-img" alt="" src="http://img.zemanta.com/pixy.gif?x-id=957af0b9-0304-8a1e-9128-4be44f8e7b1e" /></div></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">网站五月访问量的可视化</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/06/01/%E7%BD%91%E7%AB%99%E4%BA%94%E6%9C%88%E8%AE%BF%E9%97%AE%E9%87%8F%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <id>/blog/2011/06/01/网站五月访问量的可视化</id>
    <published>2011-06-01T00:00:00+08:00</published>
    <updated>2011-06-01T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p><img src="http://i.imgur.com/cc0wj.png" alt="" title="Hosted by imgur.com" /></p>

<p>今天用正在调试中的heatmap做了一个网站访问量的可视化。数据从google analytics得到，再通过我本地的geonames数据库做了geocoding（用google的就太慢了）。<a href="http://sunng.info/heatmap/googlemap.html">这里</a>有一个live版本。</p>

<p>关于这个heatmap目前还在开发中，很快会介绍给大家的。<br /><br /><div class="zemanta-pixie"><img class="zemanta-pixie-img" alt="" src="http://img.zemanta.com/pixy.gif?x-id=a1aebb1c-f22a-8723-aff4-16528e75dae4" /></div></p>



]]>
    </content>
  </entry>

</feed>
