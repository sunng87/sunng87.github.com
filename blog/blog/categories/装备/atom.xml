<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Here comes the Sun</title>
  <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/"/>
  <link rel="self" type="application/atom+xml" href="http://sunng87.github.io/blog/blog/blog/categories/装备/atom.xml"/>
  <id>http://sunng87.github.io/blog/blog/</id>
  <updated>2013-07-05T00:00:00+08:00</updated>
  <generator uri="http://octopress.org/">Octopress</generator>
  
  <rights>Copyright © 2015, Sun Ning</rights>

  <entry>
    <title type="html">Grunt for Requirejs Projects</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2013/07/05/grunt-for-requirejs-projects/"/>
    
    <id>/blog/2013/07/05/grunt-for-requirejs-projects</id>
    <published>2013-07-05T00:00:00+08:00</published>
    <updated>2013-07-05T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p><h3>the Problem</h3></p>

<p>You have modularize your JavaScript project with requirejs. And you need a build tool for both development and deployment phases, helping you to organize, optimize the source code.</p>

<p><h3>the Solution</h3></p>

<p>Grunt has been the standard tool chain for web development. I used to think the grunt configuration file could be verbose and complicated, because the JavaScript world has never come up with a standard, even common, archetype (until yeoman, but it's after Grunt). The projects are organized manually, or by some custom shell scripts. So grunt cannot take the advantage of 'convention over configuration', which Maven does well in the Java world.</p>

<p>This idea was changed until I use Grunt seriously. Grunt configuration parser has excellent support for expressions of 'path'. You can use wildcards like 'src/*.js', 'src/**/*.js', ['src/**/*.js', 'vendor/lib/*.js'] and even more 'path' to find and match your files. You don't have to write your script name one-by-one. I'm sure Grunt developers have lots of experience on JavaScript development so they know the problem.</p>

<p>So I strongly recommend you to use Grunt to manage your JavaScript project, especially when it's a large project.</p>

<p>Assume you have your JavaScript sources in 'src', and the 'src/main.js' is the entry point of your requirejs modules.</p>

<p>The first step is to create a work directory for publishing your sources, say 'public', and also put your vendor scripts in 'src/libs' Setup your first Grunt task, copy:dev. The <a href="https://github.com/gruntjs/grunt-contrib-copy">copy plugin</a> is one of the most used plugin for copying files. This will copy your source code from src/ to public/, as well as your vendor scripts.<br />
<figure class='code-highlight-figure'><div class='code-highlight'><pre class='code-highlight-pre'><div data-line='1' class='code-highlight-row numbered'><div class='code-highlight-line'><span class="na">copy</span><span class="o">:</span> <span class="p">&#x7b;</span>
</div></div><div data-line='2' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="na">dev</span><span class="o">:</span> <span class="p">&#x7b;</span>
</div></div><div data-line='3' class='code-highlight-row numbered'><div class='code-highlight-line'>    <span class="na">files</span><span class="o">:</span> <span class="p">[</span>
</div></div><div data-line='4' class='code-highlight-row numbered'><div class='code-highlight-line'>      <span class="p">&#x7b;</span><span class="na">expand</span><span class="o">:</span> <span class="no">true</span><span class="p">,</span> <span class="na">src</span><span class="o">:</span> <span class="p">[</span><span class="s">'src/**/*.js'</span><span class="p">],</span> <span class="na">dest</span><span class="o">:</span> <span class="s">'public/js'</span><span class="p">,</span> <span class="na">filter</span><span class="o">:</span> <span class="s">'isFile'</span><span class="p">&#x7d;</span>
</div></div><div data-line='5' class='code-highlight-row numbered'><div class='code-highlight-line'>    <span class="p">]</span>
</div></div><div data-line='6' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="p">&#x7d;</span>
</div></div><div data-line='7' class='code-highlight-row numbered'><div class='code-highlight-line'><span class="p">&#x7d;</span></div></div></pre></div></figure>


<p>Then move your requirejs.config from html to your main.js. Require.js is able to read configuration after it loaded your entry script. This is of great helpful for optimized code.</p>

<p>In development phase, you can have your static server over 'public'. For deployment, you need to optimize the JavaScript code: concat and uglify. This can be done with r.js, which is developed by requirejs project. Grunt also has a plugin to integrate r.js, <a href="https://github.com/gruntjs/grunt-contrib-requirejs">grunt-contrib-requirejs</a>. r.js could concat all requirejs modules by analyzing their dependency tree. You need a simple config for that:<br />
<figure class='code-highlight-figure'><div class='code-highlight'><pre class='code-highlight-pre'><div data-line='1' class='code-highlight-row numbered'><div class='code-highlight-line'><span class="nx">requirejs</span><span class="err">:</span> <span class="p">&#x7b;</span>
</div></div><div data-line='2' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="nl">compile</span><span class="p">:</span> <span class="p">&#x7b;</span>
</div></div><div data-line='3' class='code-highlight-row numbered'><div class='code-highlight-line'>    <span class="nl">options</span><span class="p">:</span> <span class="p">&#x7b;</span>
</div></div><div data-line='4' class='code-highlight-row numbered'><div class='code-highlight-line'>      <span class="nl">baseUrl</span><span class="p">:</span> <span class="s2">"src/"</span><span class="p">,</span>
</div></div><div data-line='5' class='code-highlight-row numbered'><div class='code-highlight-line'>      <span class="nx">mainConfigFile</span><span class="err">:</span> <span class="s2">"src/main.js"</span><span class="p">,</span>
</div></div><div data-line='6' class='code-highlight-row numbered'><div class='code-highlight-line'>      <span class="nx">out</span><span class="err">:</span> <span class="s2">"public/js/main.js"</span>
</div></div><div data-line='7' class='code-highlight-row numbered'><div class='code-highlight-line'>    <span class="p">&#x7d;</span>
</div></div><div data-line='8' class='code-highlight-row numbered'><div class='code-highlight-line'>  <span class="p">&#x7d;</span>
</div></div><div data-line='9' class='code-highlight-row numbered'><div class='code-highlight-line'><span class="p">&#x7d;</span></div></div></pre></div></figure>

</p>

<p>The mainConfigFile is the JavaScript file contains requirejs.config. r.js can also parse it from a requirejs module. r.js will concat and uglify all your scripts, include vendor scripts in one file, output as 'public/js/main.js'. With the same name of your entry point.</p>

<p>With that, you don't have to change any single line of js/html for switching between deployment and development. During development, requirejs loads JavaScript files on demand. While on the production, it loads main.js with all dependencies combined in.
</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">OpenStreetMap Nanjing: A Year of Edits, 2012</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2013/01/09/openstreetmap-nanjing-a-year-of-edits-2012/"/>
    
    <id>/blog/2013/01/09/openstreetmap-nanjing-a-year-of-edits-2012</id>
    <published>2013-01-09T00:00:00+08:00</published>
    <updated>2013-01-09T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>又到了A Year of Edits节目时间了，去年的场景还<a href="http://sunng.info/blog/2012/01/openstreetmap-nanjing-a-year-of-edits/" target="_blank">历历在目</a>。2012年OSM上的南京地图，变化更加可观。</p>

<p><img src="http://i.imgur.com/S4OSv.png" alt="" /></p>

<p>脚本和mapnik依然在<a href="https://gist.github.com/1639915" target="_blank">原处</a>，mapnik升级到2.1.x，配置文件有了一些变化。</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">My Favorite Feature in Leiningen 2</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2012/03/21/my-favorite-feature-in-leiningen-2/"/>
    
    <id>/blog/2012/03/21/my-favorite-feature-in-leiningen-2</id>
    <published>2012-03-21T00:00:00+08:00</published>
    <updated>2012-03-21T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>Recently, the leiningen team has released a preview version for leiningen 2. It brings <a href="https://github.com/technomancy/leiningen/blob/master/NEWS.md" target="_blank">new features</a> to the clojure build tool. But my favorite one is not listed in any document. So I would like to share with you here.</p>

<p>As you know, leiningen is a project oriented tool. It manages dependencies for a particular project. In Java world, Maven and Gradle are also working in this manner. </p>

<p>In contrast, there are tools which manages dependencies in a system scope. For instance, pip(python), npm(nodejs) and gems(ruby). One advantage of these tools is easy for evaluating a library. Concretely, when you want to test pyclj, just run "pip install pyclj" to install it. Then open a REPL and type "import pyclj". That's pretty easy.</p>

<p>But in clojure/leiningen, to take a tutorial of "core.logic", we have following steps: 
<ol>
<li>Find a right directory and type "lein new logic-abc" to create a project. </li>
<li>cd into it, edit project.clj, add core.logic as a dependency</li>
<li>Run `lein deps`</li>
<li>Start a REPL and follow the tutorial</li>
</ol></p>

<p>So I guest you must have a lot of empty projects created for such purpose. </p>

<p>Now we could say goodbye to this situation. Leiningen 2 has move its dependency management core to a new library, called <a href="https://github.com/cemerick/pomegranate" target="_blank">pomegranate</a>. Pomegranate wraps aether, which is a maven library created by sonatype. With pomegranate, we can add a maven artifact from repository to REPL classpath. Still on the core.logic example, it becomes much easier:</p>

<p>[cc lang="clojure"]<br />
$ lein2 repl<br />
Welcome to REPL-y!<br />
Clojure 1.3.0<br />
    Exit: Control+D or (exit) or (quit)<br />
Commands: (help)<br />
    Docs: (doc function-name-here)<br />
          (find-doc "part-of-name-here")<br />
  Source: (source function-name-here)<br />
          (sourcery function-name-here)<br />
 Javadoc: (javadoc java-object-or-class-here)<br />
Examples from clojuredocs.org:<br />
          (clojuredocs name-here)<br />
          (clojuredocs "ns-here" "name-here")<br />
nil<br />
user=> (use '[cemerick.pomegranate :only (add-dependencies)])<br />
nil<br />
user=> (add-dependencies :coordinates '[[org.clojure/core.logic "0.6.8"]])<br />
{[org.clojure/clojure "1.3.0"] nil, [org.clojure/core.logic "0.6.8"] #{[org.clojure/clojure "1.3.0"]}}<br />
user=> (use  '[clojure.core.logic])<br />
nilWARNING: == already refers to: #'clojure.core/== in namespace: user, being replaced by: #'clojure.core.logic/==<br />
user=> (run* [q] (== q 1))<br />
(1)<br />
[/cc]</p>

<p>Now core.logic is right on you classpath and you are ready to use any functions under the namespace. There's no need to create project, no need to care about where the jars stored. Just start a REPL at anywhere you want. When you finished, send EOF to the REPL. Nothing to clean up.</p>

<p>My jython dependency manager <a href="https://github.com/sunng87/jip" target="_blank">jip</a> has <a href="http://sunng87.github.com/jip/#section-6" target="_blank">similar feature</a> as I described above. It does great help to me. So I have been waiting for this feature in leiningen for a long time. Thanks to leiningen guys, it finally comes.</p>

<p>Edit 20120323 21:39</p>

<p>If you want to load libraries from clojars, you should explicitly add clojars in add-dependencies:<br />
[cc lang="clojure"]<br />
(add-dependencies :coordinates '[[incanter "1.2.3"]]<br />
                  :repositories (merge cemerick.pomegranate.aether/maven-central<br />
                                       {"clojars" "http://clojars.org/repo"}))<br />
[/cc]<br />
(The example is copied from Pomegranate document.)</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">刷HTC EVO 3D GSM</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2012/03/19/%E5%88%B7htc-evo-3d-gsm/"/>
    
    <id>/blog/2012/03/19/刷htc-evo-3d-gsm</id>
    <published>2012-03-19T00:00:00+08:00</published>
    <updated>2012-03-19T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>去年买的水货Desire Z在服役了刚刚一年之后就坏了，看来肯定是上了奸商的当。鉴于最近的新手机也没有什么像当时Desire Z那样一见倾心的，这次保守起见买了个行货EVO 3D。买行货的问题不仅是贵（贵很多），而且默认的ROM实在是没法用。几大国产流氓软件堂而皇之地强制安装后台运行，系统连google账户，官方market都没有。</p>

<p>那么只能刷一下了。所有的步骤开始之前都是解锁，按照官方的解锁方式(http://www.htcdev.com)基本上没有什么难度。在我的archlinux上，不需要安装HTC Sync（也没得装），只需要从aur安装android-sdk和android-sdk-platform-tools就有adb和fastboot在PATH里。唯一值得一提的是，在我的系统上fastboot oem get_identifier_token需要sudo，否则会一直wait device。除了这个小插曲以外，按照官方的步骤就可以解锁HBOOT。</p>

<p>接下来就可以刷recovery了，HTC EVO 3D GSM版的codename叫做shootru，比较可靠的一个版本是4.0.1.4-shooteru，可以在网上搜索 cwm-4.0.1.4-shooteru.img 这个文件，比较好找。继续通过 sudo fastboot flash recovery cwm-4.0.1.4-shooteru.img把recovery刷进手机。</p>

<p>接下来就是ROM的选择了。最好的选择是cyanogenmod，EVO 3D分为GSM和CDMA版，cmod 7只支持CDMA版，似乎还没有稳定的正式版。对GSM似乎有正在开发7.2，不过按照他们的说法，自从4.0发布之后，所有人的注意力都转移到基于4.0的cmod9上，所以7.2这个版本希望也比较渺茫。9.0已经有开发版本，但是都有一些还未解决的严重bug。说了这么多就是说我暂时放弃cmod了。</p>

<p>除了cmod，EVO 3D GSM上一个比较被认可的ROM叫做<a href="http://leedroid.com/evo-3d/?c=roms">LeeDrOiD</a>.从网站上下载5.3.0的发布版，拷贝到sd卡上，通过recovery就可以安装。安装之前先要清除旧的数据。剩下这一步也没有什么悬念。但是安装之后5.3.0上，WIFI无法启动。必须继续更新kernel，从<a href="http://leedroid.com/evo-3d/?c=kernels">网站上下</a>载。安装kernel的方法和之前不太一样，不能通过recovery安装。需要用一个叫做FlashImageGUI的工具，可以在网上直接搜索这个名字找到下载。剩下就很简单了。</p>

<p>折腾这么一圈，手机基本上能用了。不过我还是非常期待早日能用上cmod 9.
</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">OpenStreetMap Nanjing: A Year of Edits</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2012/01/19/openstreetmap-nanjing-a-year-of-edits/"/>
    
    <id>/blog/2012/01/19/openstreetmap-nanjing-a-year-of-edits</id>
    <published>2012-01-19T00:00:00+08:00</published>
    <updated>2012-01-19T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p><img src="http://i.imgur.com/0mVFk.png" alt="osm nanjing" /></p>

<p>这是2011年OpenStreetMap上，南京的编辑情况。高亮的部分是2011年创建或更新的要素。从这张图上可以看出最近的这一年，南京的数据从无到有到逐渐的完善，这里面倾注了本地几位贡献者结结实实的心血。</p>

<p>对这个可视化感兴趣，可以参考<a href="https://gist.github.com/1639915" target="_blank">这里的代码和样式表</a>。</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Clojure on CloudFoundry</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2012/01/13/clojure-on-cloudfoundry/"/>
    
    <id>/blog/2012/01/13/clojure-on-cloudfoundry</id>
    <published>2012-01-13T00:00:00+08:00</published>
    <updated>2012-01-13T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>In this article, I will show you how to develop and deploy clojure web application on CloudFoundry. As you may know, CloudFoundry is an opensource PaaS backed by VMWare. Java, Ruby and Nodejs are officially supported. As a JVM language, clojure is born to be also available on this platform, although it's not listed. </p>

<p>CloudFoundry accepts a .war file for Java web application deployment. So you don't need the ring-jetty-adaptor and a procfile as heroku requires. To help your development and deployment, I strongly recommend the lein-ring plugin:</p>

<p>[cc lang="clojure"]<br />
  :dev-dependencies [[lein-ring "0.5.4"]]<br />
[/cc]</p>

<p>CloudFoundry provides backend services like mysql, redis, mongodb and more. The connection information are stored as environment variables. <a href="http://env.cloudfoundry.com/env" target="_blank">Here</a> you can find a subset of them. </p>

<p>Take mongodb as example, connection information (host, port, username and password) are encoded as JSON, stored in environment variables. You can get them with this function:<br />
[cc lang="clojure"]<br />
(defn mongo-config [key]<br />
  (if-let [services (System/getenv "VCAP_SERVICES")]<br />
    (let [services-dict (json/read-json services false)]<br />
      (-> services-dict<br />
        (get "mongodb-1.8")<br />
        first<br />
        (get "credentials")<br />
        (get key)))))<br />
[/cc]</p>

<p>In the server bootstrap function, create the mongodb connection:<br />
[cc lang="clojure"]<br />
(defn app-init []<br />
  (def db-conn (make-connection<br />
                 (or (mongo-config "db") "lazypress")<br />
                   :host (or (mongo-config "hostname") "localhost")<br />
                   :port (or (mongo-config "port") 27017)))<br />
  (when-not (nil? (mongo-config "username"))<br />
    (authenticate db-conn<br />
      (mongo-config "username")<br />
      (mongo-config "password")))<br />
[/cc]<br />
By adding check for nil, local databased is also supported. This is pretty convenience for local development. These environment variables are consistent on all cloudfoundry application, so it's possible to deploy the application on multiple accounts without any changes.</p>

<p>Then you can add your web stuff just like standard clojure web development. (If you are using compojure, place your static files under resource/public.)</p>

<p>Finally, package it. (Suppose your application is named as "lazypress")<br />
[cc lang="bash"]<br />
lein ring uberwar lazypress.war<br />
[/cc]</p>

<p>Use the vmc tool to deploy it:<br />
[cc lang="bash"]<br />
vmc update lazypress<br />
[/cc]</p>

<p>For more usage about the vmc tool, you can read <a href="http://blog.cloudfoundry.com/post/13481010498/simplified-application-deployment-with-cloud-foundry-manifest" target="_blank">this article</a>.</p>

<p>So you have finished deploying your clojure web application to cloudfoundry.</p>

<p>Backed by spring and vmware, cloudfoundry is more Java-friendly than other PaaS like heroku. You don't have to start a Java process by yourself ("lein run" isn't a graceful way to start your app in product environment). And you don't have to worry about your web container settings (configure jetty with limited options via ring-jetty-adaptor). All you have to do is package the application as a portable war file, which you can deploy to tomcat, glassfish, and also cloudfoundry. The vmc tool could detect you war file and handle it correctly.</p>

<p></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Roar for Mootools 1.4</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/12/24/roar-for-mootools-1-4/"/>
    
    <id>/blog/2011/12/24/roar-for-mootools-1-4</id>
    <published>2011-12-24T00:00:00+08:00</published>
    <updated>2011-12-24T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>早在天下大势还处在分久必合的时候，那时候mootools还有不少简单实用的小库，比如我今天搜索"mootools notification"就找到这个08年的库叫做<a href="http://digitarald.de/project/roar/" target="_blank">Roar</a>。不过遗憾的是从那以后，这个库就再也没有更新过了。</p>

<p>Mootools本身也沉寂了很久，这个项目恐怕也要思考自己未来的发展方向了。今年9月Mootools迈进了1.4，API上有一些变化。现在的下载页也能看到with/without backward compatibility的版本分开下载。为了用上Roar，我尝试了这两个版本发现都不能使用。最后downgrade到1.2可以确定Roar本身在当时是没有什么问题。</p>

<p>这么多年对mootools痴心不改，所以顺手维护了一下Roar，现在可以在1.4 without compatibility的发布下运行了。主要是几个小修改，大多是一些多年deprecated函数被正式删除：
<ul>
	<li>Type常量，原先的String.type，Object.type现在统一到一个Type对象下，变成Type.isString和Type.isObject</li>
	<li>$empty 常量被删除了，现在直接用function()或Function.from()代替</li>
	<li>$pick 方法被Array.pick取代，参数现在也必须接受数组类型了</li></ul></p>

<p>	<li>$merge 方法被Object.merge取代</li>
	<li>$type 被typeOf取代</li>
	<li>函数对象的create方法被删除了，现在可以用函数对象的bind方法替代</li>
	<li>Browser.Engine 被删除了，需要用其他Browser的API替代</li></p>

<p></p>

<p>修改后的Roar，放在<a href="https://gist.github.com/1516568" target="_blank">这个gist</a>里，测试过可以在firefox和chromium上健康使用。IE没有做测试。这个08年的库，眼看四年过去了，用起来依然不错。</p>

<p>作为mootools的铁杆，我还是会一直专一地坚守下去的。（于是，我也已经变成了多年前那些我眼中为旧事物顽抗到底的老家伙了）</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">TF101 101</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/12/22/tf101-101/"/>
    
    <id>/blog/2011/12/22/tf101-101</id>
    <published>2011-12-22T00:00:00+08:00</published>
    <updated>2011-12-22T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>上周末决定不再忍耐，又入了一个大件：华硕的平板，变形金刚。TF101上市已经半年了，而且现在TF102号称四核的版本已经开始接受预订了，所以差不多也到了应该出手的时候了。因为我知道如果去等102的话，我还会像现在这样地去和103做比较。</p>

<p>选择这款的主要原因即他的键盘配置，平板加键盘的组合彻底把上网本推进深渊。对于我这种还算是制造内容比率比较高的人来说，有个强有力的输入设备是必要的。目前市面上有这种搭配的只有transformer和think的，而且think似乎又只有配图和说明，没见真正卖那款键盘的。更严重的是，当然，think太贵了。</p>

<p>接下来开始说问题：<br />
第一关叫做充电。TF101在充电方面有严重的缺陷。当电池电量极低时，会出现无法充电的情况。明明接着电源，可是电量提示一直是0%。如此情况下我整整充了一天拔下电源依然无法开机。最后看了网上的说法，在充电自动开机后关机了半个小时终于起死回生。</p>

<p>第二个小问题，键盘底座的平板本身电源是分离的，二者各自充电。所以在前面〝整整充了一天〞之前还有整整充了一晚上键盘。早晨起来键盘电满了，平板没充进去。</p>

<p>系统出厂是Android 3.0，这个系统的伟大之处在于从他一启动开始，就开始不断有程序报出错退出，不断有应用停止响应。他简直都对不起这个版本号。直到后来充上电升级到3.2之后才可以用。但是，还是有浏览器突然僵死然后突然从眼前消失的场面。再有就是机捆绑的什么人人网，电子书，开心网什么的，让你想不root都不行。</p>

<p>再有andrid 3.x上应用可能本来就不多，随机捆的又是一个流氓市场，除了满眼的流氓软件和山寨以外，就是版已经过时的软件。可怜这挺好一机器都不知道该装点什么。要说TF101硬件已经很可以了，只是配上这么个系统，用范伟的话说，白瞎你这个人了。手放键盘上，真恨不得能打开个终端来挡住这个浅薄的外观。等有时间我一定要尝试在这台机器上装个正经系统。也算是对得起这硬件了。</p>

<p>一句话概括一下的话，硬件还好，软件拉倒。</p>

<p></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Extend Slacker Server With Interceptors</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/12/18/extend-slacker-server-with-interceptors/"/>
    
    <id>/blog/2011/12/18/extend-slacker-server-with-interceptors</id>
    <published>2011-12-18T00:00:00+08:00</published>
    <updated>2011-12-18T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>An interceptor framework was introduced in slacker 0.3.0. It's designed to allow user to add custom functionality without hacking into the internal of slacker.</p>

<p>Like many server frameworks, slacker abstracts the request processing as a pipeline. The request object is modified by adding or updating attributes through each node of the pipeline. So it's easy to add your interceptor into the pipeline, with which you can get the data before and after function executed.</p>

<p>To create such an interceptor, you should use the <em>slacker.interceptor/definterceptor</em> macro and <em>slacker.interceptor/definterceptor+</em> macro:</p>

<p><blockquote>(definterceptor name<br />
  :before interceptor-function<br />
  :after interceptor-function)</blockquote></p>

<p><blockquote>(definterceptor+ name [arguments]<br />
  :before interceptor-function<br />
  :after interceptor-function)</blockquote></p>

<p>definterceptor+ can accept arguments so you can configure the interceptor when you use it.</p>

<p>See a simple example:<br />
[cc lang="clojure"]<br />
(definterceptor log-function-call<br />
  :before (fn [req] (println (str "calling " (:fname req))) req))</p>

<p>(definterceptor+ log-function-call-prefixed [prefix]<br />
  :before (fn [req] (println (str <br />
                               (if (fn? prefix) (prefix) prefix) <br />
                               " calling " <br />
                               (:fname req))) <br />
                    req))<br />
[/cc]</p>

<p>Then, add it to your slacker server by<br />
[cc lang="clojure"]<br />
(use '[slacker.interceptor])<br />
(import '[java.util Date])<br />
(start-slacker (the-ns 'slapi) 2104<br />
  :interceptors (interceptors log-function-call<br />
                              (log-function-call-prefixed <br />
                                (fn [] (.toString (Date.)))))<br />
[/cc]</p>

<p>Now you can log every function call of your slacker server.</p>

<p>For more detail about the interceptor framework, especially the request data, please check the <a href="https://github.com/sunng87/slacker/wiki/Interceptors" target="_blank">wiki page</a>.</p>

<p>In slacker 0.3.0, there is a built-in interceptor to stats function calls. You can find it at <em>slacker.interceptors.stats</em>. The stats data is expose via JMX. You can also write monitoring application to retrieve the data. 
<a href="http://imgur.com/vtOoL"><img src="http://i.imgur.com/vtOoL.png" alt="" title="Hosted by imgur.com" /></a></p>

<p>And there will be more built-in interceptors in 0.4.0, includes function call time stats and logging.</p>

<p></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">从GNOME网站安装exaile-doubanfm-gnome-shell-extension</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/12/03/%E4%BB%8Egnome%E7%BD%91%E7%AB%99%E5%AE%89%E8%A3%85exaile-doubanfm-gnome-shell-extension/"/>
    
    <id>/blog/2011/12/03/从gnome网站安装exaile-doubanfm-gnome-shell-extension</id>
    <published>2011-12-03T00:00:00+08:00</published>
    <updated>2011-12-03T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>最近GNOME发布了期待已久的extension.gnome.org，这个网站允许你直接通过浏览器安装和管理gnome-shell扩展，有点类似app store的感觉，混乱的~/.local/share/gnome-shell/extensions/终于有了一个官方的界面。</p>

<p>网站开通的第一时间，我提交了exaile-doubanfm-gnome-shell-extension，经过review和修改，这个扩展也得到了进一步的完善，适配了gnome-shell 3.2的风格。</p>

<p>你可以从这个地址直接安装启用
<a href="https://extensions.gnome.org/extension/24/exaile-doubanfm-control/" target="_blank">https://extensions.gnome.org/extension/24/exaile-doubanfm-control/</a></p>

<p>它会在exaile douban.fm启动后显示一个菜单在gnome-shell上，你可以通过这个菜单进行基本的操作。</p>

<p>如果喜欢，别忘了在extension.gnome.org上vote一下 ：）</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Clojalk SCM Visualization</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/10/30/clojalk-scm-visualization/"/>
    
    <id>/blog/2011/10/30/clojalk-scm-visualization</id>
    <published>2011-10-30T00:00:00+08:00</published>
    <updated>2011-10-30T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>最近有一个小工具非常流行（如果我没有火星的话），<a href="http://code.google.com/p/gource/" target="_blank">gource</a>，可以将你的代码历史可视化出来。<a href="http://www.youtube.com/watch?v=ELSsGXGHfZM" target="_blank">这里</a>有reddit的代码历史，fogus也把写the joy of clojure做成了<a href="http://blog.fogus.me/2011/10/27/joy-of-clojure-the-movie/" target="_blank">这样</a>的视频。</p>

<p>凑个热闹，来看看我的<a href="https://github.com/sunng87/clojalk">clojalk</a>项目可视化
<embed src="http://player.youku.com/player.php/sid/XMzE3NzU4NjE2/v.swf" quality="high" width="480" height="400" align="middle" allowscriptaccess="sameDomain" allowfullscreen="true" type="application/x-shockwave-flash"></embed>
And the video link on <a href="http://vimeo.com/31328528" target="_blank">vimeo</a>.</p>

<p>除了一名contributor，只有一个commiter。又是一幕Forever alone。
<img src="http://i.imgur.com/FXcNw.png" alt="forever alone" /></p>

<p>PS：<br />
gource上的wiki里，ffmpeg如果报错File for preset 'slow' not found的话，去掉ffmpeg的-vpre slow就OK了。
</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Upgraded to GNOME 3.2</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/10/02/upgraded-to-gnome-3-2/"/>
    
    <id>/blog/2011/10/02/upgraded-to-gnome-3-2</id>
    <published>2011-10-02T00:00:00+08:00</published>
    <updated>2011-10-02T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>ArchLinux最大的魅力就在于Rolling Release，所有的悲喜剧你都比别人早一步见证。</p>

<p>升级到GNOME 3.2后，我的gnome-settings-daemon不能正常工作，导致gtk+的主题都无效。如果没有经验你可能不太容易注意到它的真实原因。最后找到了同病相怜的人，这个问题被报告在<a href="https://bugzilla.gnome.org/show_bug.cgi?id=660664" target="_blank">这里</a>。恰好是在我发现这个问题几个小时之前。在gnome解决这个问题之前，有一个简单的workaround：
<em>sudo mv /usr/lib/gnome-settings-daemon-3.0/libcolor.so /usr/lib/gnome-settings-daemon-3.0/libcolor.so~</em></p>

<p>库加载失败后gnome-settings-daemon会自动禁用这个插件，避免出现Segmentation fault。以上的操作，at your own risk。</p>

<p>此外，gnome-shell升级到3.2以后有些api的变化，我更新了exaile豆瓣电台的gnome-shell插件，你可以顺手git pull一下。
<a href="http://www.flickr.com/photos/40741608@N08/6203348334/" title="Screenshot at 2011-10-02 17:48:51 by 贝小塔, on Flickr"><img src="http://farm7.static.flickr.com/6162/6203348334_c71d757170.jpg" width="500" height="157" alt="Screenshot at 2011-10-02 17:48:51" /></a></p>

<p></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Moving to ArchLinux</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/10/01/moving-to-archlinux/"/>
    
    <id>/blog/2011/10/01/moving-to-archlinux</id>
    <published>2011-10-01T00:00:00+08:00</published>
    <updated>2011-10-01T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p><a href="http://www.flickr.com/photos/40741608@N08/6198252182/" title="DSC_0004 by 贝小塔, on Flickr"><img src="http://farm7.static.flickr.com/6022/6198252182_656282b489.jpg" width="335" height="500" alt="DSC_0004" /></a>
这是用新入的Nikon 55-300mm的长焦镜头300端排的远处的塔吊，它与本文没有直接关系。如果实在要计算间接关系，它是我等待fedora无尽的启动时间里消磨时光的手段之一。</p>

<p>这周开始fedora彻底崩溃了，现在在默认的run-level下NetworkManager根本无法启动，次次3分钟超时。还由于不明的原因，以越来越大的概率，gdm会僵死在启动启动之前。如果切换到terminal，输入完用户名居然连password都不会prompt出来。有时甚至在runlevel3里都无法启动。本想忍下去等到下个月f16发布，但是今天晚上已经彻底无法进入系统了，算了，其实也就是挥挥刀的事情。</p>

<p>Ubuntu的回头路是走不得的，索性切换到了Arch，从此享受rolling release，不再在每年的4月10月里蠢蠢欲动惊慌失措。重装的经验和上次一样：看准分区，/home留着/干掉；在创建用户的时候看准原先用户的uid，直接用这个id创建新用户，这样$HOME自动就归属新用户了。Arch仓库里的东西甚至要比fedora还多，没有那么多洁癖，甚至Skype和IDEA的社区版都直接进了仓库。我现在年纪大了，能从仓库安装我是不会自己再去下载了。</p>

<p>其实Arch也是老朋友了，直不过以前一直把它憋在VirtualBox里，现在它从VBox里爬出来了，Ubuntu和Windows这些当年的host们被踹进去乖乖作guest了，翻身农奴这就起来把歌唱。</p>

<p></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Beginning Emacs for Clojure</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/09/19/beginning-emacs-for-clojure/"/>
    
    <id>/blog/2011/09/19/beginning-emacs-for-clojure</id>
    <published>2011-09-19T00:00:00+08:00</published>
    <updated>2011-09-19T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>没错我开始用Emacs了！对于一个使用lisp方言的开发的人来说，Emacs无疑是正统，是professional的象征。</p>

<p><a href="http://www.flickr.com/photos/40741608@N08/6162700542/" title="Screenshot--home-sun-projects-clojalk-src-clojalk-wal.clj by 贝小塔, on Flickr"><img src="http://farm7.static.flickr.com/6172/6162700542_50be6d256f.jpg" width="500" height="303" alt="Screenshot--home-sun-projects-clojalk-src-clojalk-wal.clj" /></a></p>

<p>其实用Emacs，远不需要太多的配置，就可以创建一个高效率的开发环境。我用了两天不到时间，当然还包括过去三年甚至更长时间里多次试图学习Emacs并最终半途而废残存的精力。</p>

<p>一步一步来，fedora系统的用户，比如<a href="http://superuser.com/questions/242587/install-gnu-emacs-gui-in-fedora">这位</a>，还有我，都会奇怪，命名有emacs，可是为什么没有GUI呢。因为系统自带的只是一个简单的版本，用yum安装一下emacs这个包才算是真正完整。</p>

<p>接下来要跳关了，大家注意。<a href="https://github.com/technomancy/emacs-starter-kit">Emacs-starter-kit</a>是一个帮助初学者预先配置emacs的一套默认配置文件，有了这个配置文件，也算是爬上了巨人的肩膀，省去了很多探路的时间。安装方式，把这个git仓库的master分支打包下载到~/.emacs.d/里即可（展开到这个目录）。启动emacs后，会自动安装。（作者名字很熟悉，对了，就是leiningen的作者）</p>

<p>由于package.el已经配置好了，接下来就可以安装一些必要的mode，两天的时间初探，我安装了：
<ul>
	<li>clojure-mode</li>
	<li>clojurescript-mode</li>
	<li>auto-complete</li>
	<li>color-theme-tangotango</li>
	<li>slime</li>
	<li>slime-repl</li>
</ul></p>

<p>安装方式：<br />
M-x package-install<br />
输入包名即可。</p>

<p>clojure-mode和clojurescript-mode是编辑clojure的mode，不多说。</p>

<p><h4>配色</h4>
color-theme我本来是习惯用solarized，不过尝试了几次color-theme-solarized这个包应该是有一些问题。退而选择了tangotango。要默认选择这个颜色，在init.el里加：<br />
[cc lang="lisp"]<br />
(require 'color-theme-tangotango)<br />
(color-theme-tangotango)<br />
[/cc]</p>

<p><h4>代码提示</h4>
auto-complete是代码提示和自动补全插件，安装完成后要简单配置一下才能使用：<br />
[cc lang="lisp"]<br />
(require 'auto-complete-config)<br />
(add-to-list 'ac-dictionary-directories "~/.emacs.d/elpa/auto-complete-1.4.20110207/dict/")<br />
(ac-config-default)<br />
[/cc]<br />
当然网上有更多的高级配置，可以搜一下。</p>

<p><h4>REPL</h4>
clojure的IDE必须要有repl的支持，在emacs中，repl通过slime这个mode来实现。此外还要额外安装swank：
<em>lein plugin install swank-clojure 1.3.2</em>
在项目目录通过<em>lein swank</em>启动。在emacs中：
<em>M-x slime-connect</em>
选择swank启动的host和port即可。这是一个支持tab提示的强大REPL，并且可以引用lein项目中的代码。</p>

<p>Edit/20110920<br />
其实只需要在clojure-mode中通过M-x clojure-jack-in 即可启动swank和slime。</p>

<p><h4>ParEdit</h4>
ParEdit是编辑括号的利器，Emacs-Starter-Kit已经把这个包配置好了。ParEdit不仅会自动打印括号，最强大的是还能阻止用户误删或误输入括号！有了它基本上括号的问题就轻松多了。<br />
（当然，有时候需要强制删掉括号<em>C-u DEL</em>，也可能要强制输入括号<em>C-q (</em>或<em>C-q )</em>）</p>

<p><h4>TagList</h4>
很遗憾ctags不支持clojure，而且emacs似乎也没有一个比较好的TagList。我看到有人提到imenu在一定程度上倒是可以做到类似的功能：
<em>M-x imenu<tab><tab /></tab></em></p>

<p>总得来说，捅破了窗户纸，用emacs编辑clojure还是最好的选择！
</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">用coffeescript重写了首页</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/05/13/%E7%94%A8coffeescript%E9%87%8D%E5%86%99%E4%BA%86%E9%A6%96%E9%A1%B5/"/>
    
    <id>/blog/2011/05/13/用coffeescript重写了首页</id>
    <published>2011-05-13T00:00:00+08:00</published>
    <updated>2011-05-13T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>下午有时间看了一下<a href="http://jashkenas.github.com/coffee-script/">coffeescript</a>，发现非常优雅。过去对JavaScript的工作，从dojo到jquery主要是在库的层面，这次coffeescript的出现是在语言层面对javascript做了一次加强。现在对语言的加强不再需要mozilla/microsoft/google/apple几家坐下来慢慢聊了，民间的力量就可以实现。</p>

<p>coffeescript的几个特点也属于博采众长：
<ul>
<li>类似python的，以缩进取代代码块</li>
<li>类似ruby/perl，方法调用括号可选</li>
<li>类似ruby，无须return</li>
<li>正常的类声明语法</li>
</ul></p>

<p>在nodejs的环境里可以通过npm安装coffer-script，利用它的命令行程序，可以把coffeescript编译成javascript。不过最给力的是可以在网页里通过<a href="http://jashkenas.github.com/coffee-script/#scripts">引入coffee-script.js</a>来直接执行（其实也是编译一下）coffeescript。</p>

<p>于是我顺手重写了一下首页的js，改写成coffeescript。因为少打很多() {}，手可以控制在键盘中心的，敲字的效率大大提高。用空你也可以尝试一下。<br /><br /><div class="zemanta-pixie"><img class="zemanta-pixie-img" alt="" src="http://img.zemanta.com/pixy.gif?x-id=c7456ff3-1bf5-8c54-b037-86800bd4f910" /></div></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">告别Ubuntu，迁移到Fedora 15，GNOME 3</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/04/22/%E5%91%8A%E5%88%ABubuntu%EF%BC%8C%E8%BF%81%E7%A7%BB%E5%88%B0fedora-15%EF%BC%8Cgnome-3/"/>
    
    <id>/blog/2011/04/22/告别ubuntu，迁移到fedora-15，gnome-3</id>
    <published>2011-04-22T00:00:00+08:00</published>
    <updated>2011-04-22T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p><a href="http://www.flickr.com/photos/40741608@N08/5643299802/" title="Fedora15/Gnome3 by 贝小塔, on Flickr"><img src="http://farm6.static.flickr.com/5068/5643299802_787791dd52.jpg" alt="Fedora15/Gnome3" height="313" width="500" /></a></p>

<p>昨晚终于下了决心告别Ubuntu的紫色，迎接新的GNOME3桌面。这个想法有一段时间了，Ubuntu从09年生日的时候安装在这台电脑上，已经将近两年的时间，经历了9.04, 9.10, 10.04, 10.10, 11.04五个版本，安装了GNOME, awesome, KDE, LXDE, Openbox, wmii, GNOME3, Ubuntu Netbook等等桌面环境，可以想想那种混乱。而且通过升级获得的新版本，并不能体会到快速开机这样的特性。这次unity发布以后，用了半个月，没有什么眼前一亮的感觉，操作也不太方便，于是换发行版的想法就更加强烈了。</p>

<p>我的系统之前有三个分区，分别挂载/，/home以及/opt。这次更新理想的方式就是格式化/，保留/home和/opt。之前比较讲究规范，所以/下面基本上没有什么需要备份的东西，配置文件都放在/home下面。这样用fedora的livecd安装程序手动配置磁盘分区，只格式化/就可以了。安装的过程非常顺利，重启以后就进入用户配置的界面了。</p>

<p>要把原先的/home/sun分配给新的sun用户，这里我走了一点弯路。系统可以把/home/sun目录配置给新的sun用户作为$HOME，但是目录的owner并不会根据用户名称来匹配。Ubuntu默认第一个用户的UID是1000，而Fedora创建的新用户默认是500. 我现在不确定如果把第一个用户的ID手动指定为1000会不会就直接成功。不过这个问题不大，只要启动之后用root用户把/home/sun目录chown给新的sun用户就可以了，当然文件很多是需要消耗一些时间的。</p>

<p>进入GNOME3桌面之后发现无线网络连不上，而且不弹出密码输入框。因为我最近改了无线的密码，而NetworkManager还是从gnome-keyring里去读旧的密码，所以总是连接失败。这时<font face="monospace">rm -r ~/.gnome-keyring/</font> 删除旧密码即可。</p>

<p>桌面的第二个问题是桌面背景仍然是旧的配置（只有颜色没有图片，因为GNOME3默认桌面不由Nautilus管理），这时要毫不留情地删掉所有GNOME2的配置： <font face="monospace">rm -rf ~/.gnome2 ~/.gconf ~/.gconfd </font></p>

<p>第三个问题，gnome的applition菜单非常混乱，还存着Ubuntu系统时候的内容。根据freedesktop的标准，用户的菜单配置保存在<font face="monospace">~/.config/menus</font>里，而用户菜单会从<font face="monospace">~/.local/share/applications</font>下读取所有的.desktop文件，甚至包括wine也会在这里创建自己的菜单。对付这些内容，一删了之： <font face="monospace">rm -rf ~/.local/share/applications/*</font>。这样菜单就只会从/usr/share/applications/下读取.desktop文件，这些都是最新安装的。</p>

<p>然后，然后就没有了！就可以开始享受fresh install了，甚至你打开thunderbird，所有的邮件都在那里，什么都不用再做。
<a href="http://www.flickr.com/photos/40741608@N08/5643386496/" title="Window Selector by 贝小塔, on Flickr"><img src="http://farm6.static.flickr.com/5041/5643386496_153d59d4b1.jpg" alt="Window Selector" height="313" width="500" /></a>
如果要比较gnome-shell和unity的话：
<ol>
<li>gs的启动器比unity要好用，unity的启动器搜索程序之后必须点击图标才能启动，gs可以直接回车启动第一个</li>
<li>gs的dock比unity要好用，其实都与windows7的任务栏类似，但是 unity里打开了一个终端之后，再点这个图标就转到终端，如果想新开一个就无奈了，右键点击也没有新开的选项。（难道是shift+click，来不及试了。。。）</li>
<li>unity的indicator比gs的tray强大多了，这是ubuntu的强项，从10.04开始就用自己的indicator，到了11.04已经有成熟的API，除了官方的，还有很多程序支持，还有天气、系统监控的indicator。gs抛弃了原来的panel applets，现在看天气、看系统状况都无从谈起。尤其是看不到cpu使用情况，心里总是不踏实，天知道firefox+flash又把你的系统烧了多久。</li>
</ol></p>

<p>总体来说这次重装效果非常好，基本上没有留下任何瑕疵。断断续续用了四年多的Ubuntu，再见了～<br /><br /><div class="zemanta-pixie"><img class="zemanta-pixie-img" alt="" src="http://img.zemanta.com/pixy.gif?x-id=98d4edfa-b22d-81bd-b0cc-4b2b6afdacb9" /></div></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Setting Up Soldat and Gefr</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/03/27/setting-up-soldat-and-gefr/"/>
    
    <id>/blog/2011/03/27/setting-up-soldat-and-gefr</id>
    <published>2011-03-27T00:00:00+08:00</published>
    <updated>2011-03-27T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>本文介绍soldat服务器和gefr WSGI适配器的环境搭建，以及jip的基本使用。</p>

<p><h4>安装python工具</h4>
virtualenv和pip是python开发的关键工具<br />
sudo apt-get install python-virtualenv<br />
sudo apt-get install python-pip</p>

<p>jython需要您手动下载安装。推荐安装到/usr/local/下，并建立软连接到/usr/local/bin/中，下文将假设您是这么做的。</p>

<p><h4>创建虚拟jython环境</h4>
virtualenv -p /usr/local/bin/jython gefr-test<br />
cd gefr-test<br />
source bin/activate</p>

<p><h4>安装jip</h4>
pip install jip</p>

<p><h4>配置jip</h4>
在$HOME下创建文件.jip，内容为：</p>

<p>[cc lang="ini"]<br />
[repos:oss]<br />
uri=http://oss.sonatype.org/content/repositories/snapshots/<br />
type=remote</p>

<p>[repos:central]<br />
uri=http://repo1.maven.org/maven2/<br />
type=remote</p>

<p>[repos:local]<br />
uri=/home/sun/.m2/repository/<br />
type=local<br />
[/cc]</p>

<p><h4>安装soldat</h4>
配置完jip后，可以使用jip来安装soldat<br />
jip install info.sunng.soldat:soldat:1.0-SNAPSHOT</p>

<p>文件将被下载到 javalib 目录中，您可以检查安装的正确性：<br />
$ ls javalib/<br />
log4j-1.2.16.jar     slf4j-log4j12-1.6.1.jar<br />
slf4j-api-1.6.1.jar  soldat-1.0-SNAPSHOT.jar</p>

<p><h4>安装gefr</h4>
pip install gefr==0.1dev2</p>

<p><h4>创建一个简单的Python WSGI程序</h4>
创建test.py</p>

<p>[cc lang="python"]<br />
from gefr import Gefr</p>

<p>def wsgiapp(environ, start_response):<br />
    status = '200 OK'<br />
    res_body = "<html><head><title>Welcome</title></head><body><h1>It works!</h1></body></html>"<br />
    res_headers = [('Content-Type', 'text/html'),<br />
            ('Content-Length', str(len(res_body)))]<br />
    start_response(status, res_headers)<br />
    return [res_body]</p>

<p>Gefr(wsgiapp, host='0.0.0.0', port=8000).start()<br />
[/cc]</p>

<p><h4>启动服务</h4>
使用jip附带的jython-all<br />
jython-all test.py</p>

<p>打开浏览器，访问 http://localhost:8000/</p>

<p><h4>用ab测试服务性能</h4>
$ ab -n 10000 -c 100 http://localhost:8000/
<pre>
This is ApacheBench, Version 2.3 <$Revision: 655654 $>
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/</pre></p>

<p>Benchmarking localhost (be patient)<br />
Completed 1000 requests<br />
Completed 2000 requests<br />
Completed 3000 requests<br />
Completed 4000 requests<br />
Completed 5000 requests<br />
Completed 6000 requests<br />
Completed 7000 requests<br />
Completed 8000 requests<br />
Completed 9000 requests<br />
Completed 10000 requests<br />
Finished 10000 requests</p>

<p>Server Software:        gefr/0.1dev<br />
Server Hostname:        localhost<br />
Server Port:            8000</p>

<p>Document Path:          /<br />
Document Length:        79 bytes</p>

<p>Concurrency Level:      100<br />
Time taken for tests:   2.539 seconds<br />
Complete requests:      10000<br />
Failed requests:        0<br />
Write errors:           0<br />
Total transferred:      1640000 bytes<br />
HTML transferred:       790000 bytes<br />
Requests per second:    3938.11 [#/sec] (mean)<br />
Time per request:       25.393 [ms] (mean)<br />
Time per request:       0.254 [ms] (mean, across all concurrent requests)<br />
Transfer rate:          630.71 [Kbytes/sec] received</p>

<p>Connection Times (ms)<br />
              min  mean[+/-sd] median   max<br />
Connect:        0    0   0.6      0       8<br />
Processing:     9   25  22.4     21     239<br />
Waiting:        9   25  22.4     21     239<br />
Total:         13   25  22.3     21     239</p>

<p>Percentage of the requests served within a certain time (ms)<br />
  50%     21<br />
  66%     22<br />
  75%     22<br />
  80%     23<br />
  90%     26<br />
  95%     40<br />
  98%     65<br />
  99%    233<br />
 100%    239 (longest request)
</p>

<p>Good Luck!</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">When Nodejs Meets Mapnik</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/03/05/when-nodejs-meets-mapnik/"/>
    
    <id>/blog/2011/03/05/when-nodejs-meets-mapnik</id>
    <published>2011-03-05T00:00:00+08:00</published>
    <updated>2011-03-05T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>tilelive.js是一个基于nodejs的web地图工具，帮助用户快速查看他们创建的地图样式。tilelive.js是Mapbox众多产品中的一个，你可以通过<a href="http://mapbox.github.com/tilemill/">tilemill</a>了解更多。</p>

<p>要运行tilelive.js，你需要安装一系列软件。</p>

<p><h3>安装mapnik</h3>
首先需要安装mapnik2，注意并非是目前的稳定版本0.7.1，而是开发版本。<br />
签出SVN代码：
<code>svn co http://svn.mapnik.org/trunk mapnik-trunk</code></p>

<p>按照Mapnik的<a href="http://trac.mapnik.org/browser/trunk/INSTALL">文档</a>描述进行安装。</p>

<p><h3>安装node依赖</h3>
推荐你安装最新的node 0.4.2和npm 0.3.1。</p>

<p>安装npm后执行
<code>npm config set unsafe-perm true</code>
去除超级用户运行npm时的警告。</p>

<p>接下来就可以安装一系列node modules了：
<code>sudo npm install mapnik</code>
<code>sudo npm install carto</code>
<code>sudo npm install generic-pool</code>
<code>sudo npm install underscore</code>
<code>sudo npm install node-get</code>
<code>sudo npm install step</code>
<code>sudo npm install express</code>
<code>sudo npm install sqlite3</code>
<code>sudo npm install compress</code></p>

<p><h3>签出 tilelive.js</h3>
tilelive.js并不兼容最新的node 0.4.x和express 2.0.0，所以你可以签出我fork的版本：
<code>git clone git://github.com/sunng87/tilelive.js.git</code>
<code>git checkout new-fork</code></p>

<p>运行：
<code>./bin/tilelive_server.js examples/stysheet.xml</code></p>

<p>打开浏览器，访问 http://localhost:8888/ 即可
<a href="http://www.flickr.com/photos/40741608@N08/5498409697/" title="screenshot_001 by 贝小塔, on Flickr"><img src="http://farm6.static.flickr.com/5177/5498409697_6bf280e8fb.jpg" width="500" height="405" alt="screenshot_001" /></a></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">pgpoolII的管理功能</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/02/14/pgpoolii%E7%9A%84%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD/"/>
    
    <id>/blog/2011/02/14/pgpoolii的管理功能</id>
    <published>2011-02-14T00:00:00+08:00</published>
    <updated>2011-02-14T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>pgpool是postgresql的中间件，他的主要功能包括：
<ul>
<li>Connection Pooling 连接池</li>
<li>Replication 双写</li>
<li>Load Balance 负载均衡</li>
<li>Limiting Exceeding Connections 连接限制</li>
<li>Parallel Query 并行查询</li>
</ul></p>

<p>除此以外，pgpool还提供了对数据库节点的健康检查功能，自动fail over。</p>

<p>对pgpool的管理，pgpool本身除了工作端口（默认5433）以外，还开放一个pcp端口9898，类似FTP的控制端口。通过pcp端口可以获取pgpool的运行时信息，也可以进行运行时的操作。这些功能罗列在：<br />
http://pgpool.projects.postgresql.org/pgpool-II/doc/pgpool-en.html#reference</p>

<p>封装这些命令的二进制文件也随着pgpool发行，由于是通过网络通信，所以并不要求这些工具与pgpool安装在同一台机器上。</p>

<p>除此以外，为了用户友好，pgpool还有一个具有UI的用户管理工具。这个工具的功能包括：
<ul>
<li>系统信息，主要是pcp的信息</li>
<li>配置文件编辑，这个功能似乎要求pgpooladmin和pgpool安装在一台机器上以便直接都写配置文件</li>
<li>切分规则编辑</li>
</ul></p>

<p>另外，pgpool还通过一些自定义的SQL语句允许用户从工作端口提取一些配置信息和运行时信息：<br />
http://pgpool.projects.postgresql.org/pgpool-II/doc/pgpool-en.html#show-commands</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">包管理与路径管理</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/01/22/%E5%8C%85%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B7%AF%E5%BE%84%E7%AE%A1%E7%90%86/"/>
    
    <id>/blog/2011/01/22/包管理与路径管理</id>
    <published>2011-01-22T00:00:00+08:00</published>
    <updated>2011-01-22T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>现在几乎每一种语言都有一些依赖管理工具，或者是中央的包仓库。比如这些：
<ul>
<li>Java: maven, ivy, gradle</li>
<li>Ruby: gems</li>
<li>Python: easy_install, pip</li>
<li>Clojure: leinigen</li>
<li>Groovy: maven, grape, gradle</li>
<li>Hashkell: cabal</li>
<li>PHP: pear</li>
<li>Nodejs: npm</li>
</ul></p>

<p>这些工具在管理包和路径时都会采用各不相同的策略，有的是通过自身实现，有的是借助语言平台本身的特点。</p>

<p><h3>Java</h3>
其中最注明的Maven，它的方式是在POM文件中定义你的依赖，Maven会在本地仓库中维护这些依赖。Maven的本地仓库默认是在$HOME/.m2/repository目录下，是用户独立的，当然要下载一个依赖也不需要root权限。而在通过Maven运行Java项目时，Maven插件会自动管理classpath，你并不需要把这些依赖从本地仓库里拷贝出来而单独维护一个所谓lib目录（这样也不好管理）。这是Maven的方式，目前看来，这也是最经典的一种方式。除了maven本身的特性以外，这也和Java的classpath机制有关。</p>

<p>最近势头很猛的Java构建工具gradle，方式也与Maven类似，它会把下载的依赖存放在$HOME/.gradle/cache目录里，并自动管理classpath。</p>

<p>同样是Java，与maven相对应的是ant+ivy。ivy可以为你管理依赖，但是ivy不会帮你管理classpath。ivy的包管理，是以project为scope的，你需要维护一个lib目录来存放这些下载的包，再通过传统的ant的方式去管理classpath，从而使项目可以进行编译和运行。</p>

<p>在Java世界里，还有一个特别的工具叫做grape，它是专门用于groovy的轻量级的依赖解决方案。grape是以脚本为scope，在需要依赖的脚本中通过@Grab声明依赖，grape工具可以从maven仓库中下载依赖到$HOME/.groovy/grapes中，并把相关的依赖加入groovy的classpath。除此以外，grape还有一个命令行工具帮助你手动下载依赖到本地仓库。grape的内部是基于ivy的，不过它的方式比ant要自动化很多。</p>

<p>在Java世界里还有一个特例，是Clojure的依赖管理工具leiningen。leiningen本身也比较简单，它的方式与ivy相同，会解析project.clj文件中定义的依赖关系，并下载到当前的工程目录下的lib中。lein是鼓励通过uberjar的方式把依赖统统打包的，所以它并没有classpath的管理功能。</p>

<p>总体来说，Java世界的工具和Java是相似的，其最大特点就是System independent，安装包不需要root权限，每次的运行都需要管理classpath。作为开发人员，classpath中有哪些可以访问的类库是可以控制的，这也使Java程序的移植性得到良好的控制和管理。</p>

<p><h3>Python</h3>
与Java不同，Python通常作为系统分发的一部分，他的包管理和PATH管理要相对混乱一些。通常我们有两种方式来安装一个Python的软件包：
<ul>
<li>sudo apt-get install python-redis</li>
<li>sudo easy_install redis</li>
</ul>
一种是通过系统的包管理工具（如apt-get）从系统的软件仓库里安装，一种是通过python自己的包管理工具（如easy_install / pip）从Python Cheese Shop中下载安装。这两种安装方式有什么不同呢。以Ubuntu为例，通过apt-get安装的python包通常会被放在 /usr/share/pyshared 或 /usr/lib/python2.6/dist-packages 中，相对应的，由easy_install安装的Python包，则存放在 /usr/local/lib/python2.6/dist-packages 中。Python启动后可以通过查看sys.path来了解当前的path情况。</p>

<p>除了安装到系统目录，easy_install可以通过 --user 选项来把软件包安装到用户目录 $HOME/.local/lib/python2.6/site-packages。不过无论是系统级别还是用户级别，python都很难在启动时管理Path，即任何时候python都可以访问安装在系统中的所有软件包。这导致了混乱的情况，导致编写的python软件难以进行依赖管理和移植（即使没有定义在setup.py中，很多依赖还是可以访问的）。</p>

<p>由此virtualenv营运而生，virtualenv帮助你创建一个独立的python运行环境。激活这个小环境之后，easy_install/pip仅仅安装软件到小环境，python仅能访问环境内部的site-packages，这样整个环境中的依赖关系就非常清楚，也保障了程序的移植性。这样，就将原本系统scope的python包管理级别改进为项目级别。我之前写的jip也是将依赖下载或拷贝到virtualenv的小环境中，并且修改jython的启动脚本修改PYTHONPATH的设置，保证Java依赖对Jython的透明可访问。</p>

<p><h3>Nodejs</h3>
nodejs是一个新兴的生态系统，一个包管理工具对其也是必不可少。npm是目前整个社区都比较认可的工具。</p>

<p>不过目前npm并不好用。npm默认会把自己安装到 node安装前缀的目录，比如node安装时你选择了默认前缀/usr/local，那么npm会把自己安装到/usr/local/lib/node里。这个目录是系统级别的，所以需要root权限，而npm本身又不鼓励用户用root权限来安装软件包（安全问题）。所以作者说希望用户把/usr/local/lib/node权限授予用户，或者把node安装到用户目录里。这两种方式其实都不太优雅。</p>

<p>Ruby的gems在这方面最符合unix哲学，即用户知道自己在做什么。如果用户以root权限运行gem  install，gem会把软件包安装到系统目录中对所有用户可用，而如果以普通用户权限运行，则安装到用户目录 $HOME/.gem 中仅当前用户可见。</p>

<p>nodejs在加载软件包时，会在require.paths中的几个目录里查找，前两个都是用户目录，所以npm也并非一定要把包安装到系统目录里去。虽然现在可以用过修改.npmrc文件在修改npm的默认行为，不过在这个CoC的时代，显然太繁琐了。</p>

<p><h3>Best Pratice</h3>
总结一下，包管理和路径管理的最佳实践应该是：语言平台有CoC的路径机制，包管理器有基于环境变量、用户权限的判断执行合适行为。</p>



]]>
    </content>
  </entry>

</feed>
