<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 装备 | Here comes the Sun]]></title>
  <link href="http://sunng87.github.io/blog//blog/categories/zhuang-bei/atom.xml" rel="self"/>
  <link href="http://sunng87.github.io/blog//"/>
  <updated>2014-05-27T22:33:17+08:00</updated>
  <id>http://sunng87.github.io/blog//</id>
  <author>
    <name><![CDATA[Sun Ning]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Grunt for Requirejs Projects]]></title>
    <link href="http://sunng87.github.io/blog//blog/2013/07/05/grunt-for-requirejs-projects/"/>
    <updated>2013-07-05T00:00:00+08:00</updated>
    <id>http://sunng87.github.io/blog//blog/2013/07/05/grunt-for-requirejs-projects</id>
    <content type="html"><![CDATA[<p><h3>the Problem</h3></p>




<p>You have modularize your JavaScript project with requirejs. And you need a build tool for both development and deployment phases, helping you to organize, optimize the source code.</p>




<p><h3>the Solution</h3></p>




<p>Grunt has been the standard tool chain for web development. I used to think the grunt configuration file could be verbose and complicated, because the JavaScript world has never come up with a standard, even common, archetype (until yeoman, but it's after Grunt). The projects are organized manually, or by some custom shell scripts. So grunt cannot take the advantage of 'convention over configuration', which Maven does well in the Java world.</p>




<p>This idea was changed until I use Grunt seriously. Grunt configuration parser has excellent support for expressions of 'path'. You can use wildcards like 'src/*.js', 'src/**/*.js', ['src/**/*.js', 'vendor/lib/*.js'] and even more 'path' to find and match your files. You don't have to write your script name one-by-one. I'm sure Grunt developers have lots of experience on JavaScript development so they know the problem.</p>




<p>So I strongly recommend you to use Grunt to manage your JavaScript project, especially when it's a large project.</p>




<p>Assume you have your JavaScript sources in 'src', and the 'src/main.js' is the entry point of your requirejs modules.</p>




<p><p>The first step is to create a work directory for publishing your sources, say &lsquo;public&rsquo;, and also put your vendor scripts in &lsquo;src/libs&rsquo; Setup your first Grunt task, copy:dev. The <a href="https://github.com/gruntjs/grunt-contrib-copy">copy plugin</a> is one of the most used plugin for copying files. This will copy your source code from src/ to public/, as well as your vendor scripts.<br />
``` coffeescript
copy: {
  dev: {</p>

<pre><code>files: [
  {expand: true, src: ['src/**/*.js'], dest: 'public/js', filter: 'isFile'}
]
</code></pre>

<p>  }
}
```</p>

<p><p>Then move your requirejs.config from html to your main.js. Require.js is able to read configuration after it loaded your entry script. This is of great helpful for optimized code.</p></p>

<p><p>In development phase, you can have your static server over &lsquo;public&rsquo;. For deployment, you need to optimize the JavaScript code: concat and uglify. This can be done with r.js, which is developed by requirejs project. Grunt also has a plugin to integrate r.js, <a href="https://github.com/gruntjs/grunt-contrib-requirejs">grunt-contrib-requirejs</a>. r.js could concat all requirejs modules by analyzing their dependency tree. You need a simple config for that:<br />
``` javascript
requirejs: {
  compile: {</p>

<pre><code>options: {
  baseUrl: "src/",
  mainConfigFile: "src/main.js",
  out: "public/js/main.js"
}
</code></pre>

<p>  }
}
```
</p></p>

<p><p>The mainConfigFile is the JavaScript file contains requirejs.config. r.js can also parse it from a requirejs module. r.js will concat and uglify all your scripts, include vendor scripts in one file, output as &lsquo;public/js/main.js&rsquo;. With the same name of your entry point.</p></p>

<p><p>With that, you don&rsquo;t have to change any single line of js/html for switching between deployment and development. During development, requirejs loads JavaScript files on demand. While on the production, it loads main.js with all dependencies combined in.
</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenStreetMap Nanjing: A Year of Edits, 2012]]></title>
    <link href="http://sunng87.github.io/blog//blog/2013/01/09/openstreetmap-nanjing-a-year-of-edits-2012/"/>
    <updated>2013-01-09T00:00:00+08:00</updated>
    <id>http://sunng87.github.io/blog//blog/2013/01/09/openstreetmap-nanjing-a-year-of-edits-2012</id>
    <content type="html"><![CDATA[<p>又到了A Year of Edits节目时间了，去年的场景还<a href="http://sunng.info/blog/2012/01/openstreetmap-nanjing-a-year-of-edits/" target="_blank">历历在目</a>。2012年OSM上的南京地图，变化更加可观。</p>




<p><img src="http://i.imgur.com/S4OSv.png" alt="" /></p>




<p>脚本和mapnik依然在<a href="https://gist.github.com/1639915" target="_blank">原处</a>，mapnik升级到2.1.x，配置文件有了一些变化。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Favorite Feature in Leiningen 2]]></title>
    <link href="http://sunng87.github.io/blog//blog/2012/03/21/my-favorite-feature-in-leiningen-2/"/>
    <updated>2012-03-21T00:00:00+08:00</updated>
    <id>http://sunng87.github.io/blog//blog/2012/03/21/my-favorite-feature-in-leiningen-2</id>
    <content type="html"><![CDATA[<p>Recently, the leiningen team has released a preview version for leiningen 2. It brings <a href="https://github.com/technomancy/leiningen/blob/master/NEWS.md" target="_blank">new features</a> to the clojure build tool. But my favorite one is not listed in any document. So I would like to share with you here.</p>




<p>As you know, leiningen is a project oriented tool. It manages dependencies for a particular project. In Java world, Maven and Gradle are also working in this manner. </p>




<p>In contrast, there are tools which manages dependencies in a system scope. For instance, pip(python), npm(nodejs) and gems(ruby). One advantage of these tools is easy for evaluating a library. Concretely, when you want to test pyclj, just run "pip install pyclj" to install it. Then open a REPL and type "import pyclj". That's pretty easy.</p>




<p>But in clojure/leiningen, to take a tutorial of "core.logic", we have following steps: 
<ol>
<li>Find a right directory and type "lein new logic-abc" to create a project. </li>
<li>cd into it, edit project.clj, add core.logic as a dependency</li>
<li>Run `lein deps`</li>
<li>Start a REPL and follow the tutorial</li>
</ol></p>




<p>So I guest you must have a lot of empty projects created for such purpose. </p>




<p>Now we could say goodbye to this situation. Leiningen 2 has move its dependency management core to a new library, called <a href="https://github.com/cemerick/pomegranate" target="_blank">pomegranate</a>. Pomegranate wraps aether, which is a maven library created by sonatype. With pomegranate, we can add a maven artifact from repository to REPL classpath. Still on the core.logic example, it becomes much easier:</p>




<p>[cc lang="clojure"]<br />
$ lein2 repl<br />
Welcome to REPL-y!<br />
Clojure 1.3.0<br />
    Exit: Control+D or (exit) or (quit)<br />
Commands: (help)<br />
    Docs: (doc function-name-here)<br />
          (find-doc "part-of-name-here")<br />
  Source: (source function-name-here)<br />
          (sourcery function-name-here)<br />
 Javadoc: (javadoc java-object-or-class-here)<br />
Examples from clojuredocs.org:<br />
          (clojuredocs name-here)<br />
          (clojuredocs "ns-here" "name-here")<br />
nil<br />
user=> (use '[cemerick.pomegranate :only (add-dependencies)])<br />
nil<br />
user=> (add-dependencies :coordinates '[[org.clojure/core.logic "0.6.8"]])<br />
{[org.clojure/clojure "1.3.0"] nil, [org.clojure/core.logic "0.6.8"] #{[org.clojure/clojure "1.3.0"]}}<br />
user=> (use  '[clojure.core.logic])<br />
nilWARNING: == already refers to: #'clojure.core/== in namespace: user, being replaced by: #'clojure.core.logic/==<br />
user=> (run* [q] (== q 1))<br />
(1)<br />
[/cc]</p>




<p>Now core.logic is right on you classpath and you are ready to use any functions under the namespace. There's no need to create project, no need to care about where the jars stored. Just start a REPL at anywhere you want. When you finished, send EOF to the REPL. Nothing to clean up.</p>




<p>My jython dependency manager <a href="https://github.com/sunng87/jip" target="_blank">jip</a> has <a href="http://sunng87.github.com/jip/#section-6" target="_blank">similar feature</a> as I described above. It does great help to me. So I have been waiting for this feature in leiningen for a long time. Thanks to leiningen guys, it finally comes.</p>




<p>Edit 20120323 21:39</p>




<p>If you want to load libraries from clojars, you should explicitly add clojars in add-dependencies:<br />
[cc lang="clojure"]<br />
(add-dependencies :coordinates '[[incanter "1.2.3"]]<br />
                  :repositories (merge cemerick.pomegranate.aether/maven-central<br />
                                       {"clojars" "http://clojars.org/repo"}))<br />
[/cc]<br />
(The example is copied from Pomegranate document.)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[刷HTC EVO 3D GSM]]></title>
    <link href="http://sunng87.github.io/blog//blog/2012/03/19/%E5%88%B7htc-evo-3d-gsm/"/>
    <updated>2012-03-19T00:00:00+08:00</updated>
    <id>http://sunng87.github.io/blog//blog/2012/03/19/刷htc-evo-3d-gsm</id>
    <content type="html"><![CDATA[<p>去年买的水货Desire Z在服役了刚刚一年之后就坏了，看来肯定是上了奸商的当。鉴于最近的新手机也没有什么像当时Desire Z那样一见倾心的，这次保守起见买了个行货EVO 3D。买行货的问题不仅是贵（贵很多），而且默认的ROM实在是没法用。几大国产流氓软件堂而皇之地强制安装后台运行，系统连google账户，官方market都没有。</p>




<p>那么只能刷一下了。所有的步骤开始之前都是解锁，按照官方的解锁方式(http://www.htcdev.com)基本上没有什么难度。在我的archlinux上，不需要安装HTC Sync（也没得装），只需要从aur安装android-sdk和android-sdk-platform-tools就有adb和fastboot在PATH里。唯一值得一提的是，在我的系统上fastboot oem get_identifier_token需要sudo，否则会一直wait device。除了这个小插曲以外，按照官方的步骤就可以解锁HBOOT。</p>




<p>接下来就可以刷recovery了，HTC EVO 3D GSM版的codename叫做shootru，比较可靠的一个版本是4.0.1.4-shooteru，可以在网上搜索 cwm-4.0.1.4-shooteru.img 这个文件，比较好找。继续通过 sudo fastboot flash recovery cwm-4.0.1.4-shooteru.img把recovery刷进手机。</p>




<p>接下来就是ROM的选择了。最好的选择是cyanogenmod，EVO 3D分为GSM和CDMA版，cmod 7只支持CDMA版，似乎还没有稳定的正式版。对GSM似乎有正在开发7.2，不过按照他们的说法，自从4.0发布之后，所有人的注意力都转移到基于4.0的cmod9上，所以7.2这个版本希望也比较渺茫。9.0已经有开发版本，但是都有一些还未解决的严重bug。说了这么多就是说我暂时放弃cmod了。</p>




<p>除了cmod，EVO 3D GSM上一个比较被认可的ROM叫做<a href="http://leedroid.com/evo-3d/?c=roms">LeeDrOiD</a>.从网站上下载5.3.0的发布版，拷贝到sd卡上，通过recovery就可以安装。安装之前先要清除旧的数据。剩下这一步也没有什么悬念。但是安装之后5.3.0上，WIFI无法启动。必须继续更新kernel，从<a href="http://leedroid.com/evo-3d/?c=kernels">网站上下</a>载。安装kernel的方法和之前不太一样，不能通过recovery安装。需要用一个叫做FlashImageGUI的工具，可以在网上直接搜索这个名字找到下载。剩下就很简单了。</p>




<p>折腾这么一圈，手机基本上能用了。不过我还是非常期待早日能用上cmod 9.
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenStreetMap Nanjing: A Year of Edits]]></title>
    <link href="http://sunng87.github.io/blog//blog/2012/01/19/openstreetmap-nanjing-a-year-of-edits/"/>
    <updated>2012-01-19T00:00:00+08:00</updated>
    <id>http://sunng87.github.io/blog//blog/2012/01/19/openstreetmap-nanjing-a-year-of-edits</id>
    <content type="html"><![CDATA[<p><img src="http://i.imgur.com/0mVFk.png" alt="osm nanjing" /></p>




<p>这是2011年OpenStreetMap上，南京的编辑情况。高亮的部分是2011年创建或更新的要素。从这张图上可以看出最近的这一年，南京的数据从无到有到逐渐的完善，这里面倾注了本地几位贡献者结结实实的心血。</p>




<p>对这个可视化感兴趣，可以参考<a href="https://gist.github.com/1639915" target="_blank">这里的代码和样式表</a>。</p>

]]></content>
  </entry>
  
</feed>
