
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>车水马龙</title>
  <meta name="author" content="Sun Ning">

  
  <meta name="description" content="在所有的clojure web开发例子里，对模板的介绍都很少。很多的简单例子都是以hiccup作为页面生成的手段。hiccup是个clojure的html DSL，例子里用这样的DSL生成页面确实很酷，可是他是real world吗，当然不是。 好在clojure世界里早就有了enlive， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://sunng87.github.io/blog//blog/page/6">
  <link href="/blog/favicon.png" rel="icon">
  <link href="/blog/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/blog/atom.xml" rel="alternate" title="车水马龙" type="application/atom+xml">
  <script src="/blog/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/blog/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/blog/">车水马龙</a></h1>
  
    <h2>here comes the sun</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/blog/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:sunng87.github.io/blog/" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/blog/">Blog</a></li>
  <li><a href="/blog/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2011/12/29/%E4%BD%BF%E7%94%A8enlive%E4%BD%9C%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/">使用Enlive作为模板引擎</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-29T00:00:00+08:00" pubdate data-updated="true">Dec 29<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在所有的clojure web开发例子里，对模板的介绍都很少。很多的简单例子都是以hiccup作为页面生成的手段。hiccup是个clojure的html DSL，例子里用这样的DSL生成页面确实很酷，可是他是real world吗，当然不是。</p>

<p>好在clojure世界里早就有了enlive，它不仅是一个通过css selector解析html的库，本身也可以作为模板引擎应用在web开发中。我不知道这种通过css selector的方式是否是enlive首创，不过他实在是非常新颖独特，而且平滑了页面设计和程序的集成。</p>

<p>例如这样一个模板 index.html：<br />
[cc lang=&#8221;html&#8221;]
<div id="cc">Sample Text</div>
[/cc]</p>

<p>在clojure程序中，使用enlive的deftemplate<br />
[cc lang=&#8221;clojure&#8221;]<br />
(deftemplate index &#8220;index.html&#8221;<br />
  [ctx]<br />
  [:div#cc] (content (:data ctx)))<br />
[/cc]</p>

<p>在控制器里，可以很MVC地渲染页面<br />
[cc lang=&#8221;clojure&#8221;]<br />
(index {:data &#8220;rendered text&#8221;})<br />
[/cc]</p>

<p>除了content用于渲染文本，还有html-content可以渲染含html标签的内容，以及set-attr用来修改页面元素的属性。</p>

<p>和传统的模板引擎相比，最大的不同是enlive里没有嵌入模板的直观的控制流，没有循环和条件判断，但是并非不可实现。</p>

<p>循环输出一组list</p>

<p>页面 list.html<br />
[cc lang=&#8221;html&#8221;]
<ul id="the-list">
<li class="list-item"></li>
</ul>
[/cc]</p>

<p>定义一个enlive的snippet<br />
[cc lang=&#8221;clojure&#8221;]<br />
(defsnippet item-model &#8220;page.html&#8221; [:.list-item]<br />
  [ctx]<br />
  [:.list-item] (content (:data ctx)))<br />
[/cc]</p>

<p>在页面模板里<br />
[cc lang=&#8221;clojure&#8221;]<br />
(deftemplate list-page &#8220;list.html&#8221;<br />
  [ctx]<br />
  [:ul#the-list] (content (map item-model (:some-list ctx))))<br />
[/cc]</p>

<p>这样在页面里列表项会被循环输出，而在页面设计时这里可以放任意个li，并且直接交给后台作为模板。</p>

<p>条件判断</p>

<p>页面，设计时显示所有的内容 msg.html<br />
[cc lang=&#8221;html&#8221;]
<span id="msg">只在一定条件下显示</span>
[/cc]</p>

<p>在模板中通过clojure的if进行判断<br />
[cc lang=&#8221;clojure&#8221;]<br />
(deftemplate msg &#8220;msg.html&#8221;<br />
  [ctx]<br />
  [:span#msg] (if (:show ctx) identity (html-content &#8220;&#8221;)))<br />
[/cc]</p>

<p>解决了这两个问题，基本上用enlive作为模板引擎就没有障碍了。不过enlive也有一点小问题，其一可能是性能的问题，方便的selector显然要比传统的模板语言消耗更多的CPU。另外，在开发过程里，页面文件在服务器启动后不能热加载，修改页面必须重启ring才能看到。也许有时间的话，可以给它加一个reload选项。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2011/12/24/roar-for-mootools-1-4/">Roar for Mootools 1.4</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-24T00:00:00+08:00" pubdate data-updated="true">Dec 24<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>早在天下大势还处在分久必合的时候，那时候mootools还有不少简单实用的小库，比如我今天搜索&#8221;mootools notification&#8221;就找到这个08年的库叫做<a href="http://digitarald.de/project/roar/" target="_blank">Roar</a>。不过遗憾的是从那以后，这个库就再也没有更新过了。</p>

<p>Mootools本身也沉寂了很久，这个项目恐怕也要思考自己未来的发展方向了。今年9月Mootools迈进了1.4，API上有一些变化。现在的下载页也能看到with/without backward compatibility的版本分开下载。为了用上Roar，我尝试了这两个版本发现都不能使用。最后downgrade到1.2可以确定Roar本身在当时是没有什么问题。</p>

<p>这么多年对mootools痴心不改，所以顺手维护了一下Roar，现在可以在1.4 without compatibility的发布下运行了。主要是几个小修改，大多是一些多年deprecated函数被正式删除：
<ul>
	<li>Type常量，原先的String.type，Object.type现在统一到一个Type对象下，变成Type.isString和Type.isObject</li>
	<li>$empty 常量被删除了，现在直接用function()或Function.from()代替</li>
	<li>$pick 方法被Array.pick取代，参数现在也必须接受数组类型了</li></ul></p>

<p>	<li>$merge 方法被Object.merge取代</li>
	<li>$type 被typeOf取代</li>
	<li>函数对象的create方法被删除了，现在可以用函数对象的bind方法替代</li>
	<li>Browser.Engine 被删除了，需要用其他Browser的API替代</li></p>

<p></p>

<p>修改后的Roar，放在<a href="https://gist.github.com/1516568" target="_blank">这个gist</a>里，测试过可以在firefox和chromium上健康使用。IE没有做测试。这个08年的库，眼看四年过去了，用起来依然不错。</p>

<p>作为mootools的铁杆，我还是会一直专一地坚守下去的。（于是，我也已经变成了多年前那些我眼中为旧事物顽抗到底的老家伙了）</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2011/12/22/tf101-101/">TF101 101</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-22T00:00:00+08:00" pubdate data-updated="true">Dec 22<span>nd</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>上周末决定不再忍耐，又入了一个大件：华硕的平板，变形金刚。TF101上市已经半年了，而且现在TF102号称四核的版本已经开始接受预订了，所以差不多也到了应该出手的时候了。因为我知道如果去等102的话，我还会像现在这样地去和103做比较。</p>

<p>选择这款的主要原因即他的键盘配置，平板加键盘的组合彻底把上网本推进深渊。对于我这种还算是制造内容比率比较高的人来说，有个强有力的输入设备是必要的。目前市面上有这种搭配的只有transformer和think的，而且think似乎又只有配图和说明，没见真正卖那款键盘的。更严重的是，当然，think太贵了。</p>

<p>接下来开始说问题：<br />
第一关叫做充电。TF101在充电方面有严重的缺陷。当电池电量极低时，会出现无法充电的情况。明明接着电源，可是电量提示一直是0%。如此情况下我整整充了一天拔下电源依然无法开机。最后看了网上的说法，在充电自动开机后关机了半个小时终于起死回生。</p>

<p>第二个小问题，键盘底座的平板本身电源是分离的，二者各自充电。所以在前面〝整整充了一天〞之前还有整整充了一晚上键盘。早晨起来键盘电满了，平板没充进去。</p>

<p>系统出厂是Android 3.0，这个系统的伟大之处在于从他一启动开始，就开始不断有程序报出错退出，不断有应用停止响应。他简直都对不起这个版本号。直到后来充上电升级到3.2之后才可以用。但是，还是有浏览器突然僵死然后突然从眼前消失的场面。再有就是机捆绑的什么人人网，电子书，开心网什么的，让你想不root都不行。</p>

<p>再有andrid 3.x上应用可能本来就不多，随机捆的又是一个流氓市场，除了满眼的流氓软件和山寨以外，就是版已经过时的软件。可怜这挺好一机器都不知道该装点什么。要说TF101硬件已经很可以了，只是配上这么个系统，用范伟的话说，白瞎你这个人了。手放键盘上，真恨不得能打开个终端来挡住这个浅薄的外观。等有时间我一定要尝试在这台机器上装个正经系统。也算是对得起这硬件了。</p>

<p>一句话概括一下的话，硬件还好，软件拉倒。</p>

<p></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2011/12/19/finished-my-machine-learning-courses/">Finished My Machine Learning Courses</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-19T00:00:00+08:00" pubdate data-updated="true">Dec 19<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>经过三个月的时间，终于看完了ml-class的所有视频课程，完成了所有review questions，提交了所有programming exercises.感觉不错，之前一直对数据挖掘相关的方面感兴趣，回想一下大学时候一些地统计分析甚至遥感图像数据处理的课都跟机器学习相关，但是毕竟不是这方面的课程，所以介绍的不是很系统。今年秋天斯坦福推出这个在线课程，机器学习作为其中之一真算是弥补了我们民间科学爱好者的遗憾了。</p>

<p>这个课程在有限的篇幅里涵盖了linear regression, logistic regression, ANN, SVM, PCA, K-Means, Anomaly Detection等等知识，基本上算是一个完整实用的导论。Andrew Ng教授的讲解也算是通俗易懂深入浅出，完全感觉不到什么门槛。</p>

<p>对于online course这种形式，今年秋天斯坦福的人工智能、数据库、机器学习也算是首开先河，目前这三门课程都已经结束，网上的反响非常强烈。好消息是明年Q1斯坦福还有更多数量更多方向的课程。今天MIT也宣布了明年的online course计划，他们也将加入提供在线课程的行列。而且，MIT的在线课程还会颁发一个名叫MITx的certification。开放式课程已经成为大势所趋，信息本应自由传播。</p>

<p>对于对机器学习感兴趣的朋友，除了ml-class.org上的资源，你还可以在academic earth上找到ANG教授的授课视频。这套视频涵盖的内容比ml-class上的更详细完整：
<a href="http://academicearth.org/courses/machine-learning" target="_blank">http://academicearth.org/courses/machine-learning</a></p>

<p>课程结束，我在ml-class上所有的编程作业都已经放在bitbucket上，如果有兴趣可以参考这些octave程序：
<a href="https://bitbucket.org/sunng/ml-class" target="_blank">https://bitbucket.org/sunng/ml-class</a></p>

<p>明年一月斯坦福还会开放更多跟机器学习相关的课程，包括：
<ul>
	<li>Probabilistic Graphical Models <a href="http://www.pgm-class.org/" target="_blank">pgm-class.org</a></li>
	<li>Natural Language Processing <a href="http://www.nlp-class.org" target="_blank">nlp-class.org</a></li></ul></p>

<p></p>

<p>Thank you, Professor Ng and your team for this well-prepared, high-quality online course.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2011/12/18/extend-slacker-server-with-interceptors/">Extend Slacker Server With Interceptors</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-18T00:00:00+08:00" pubdate data-updated="true">Dec 18<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>An interceptor framework was introduced in slacker 0.3.0. It&#8217;s designed to allow user to add custom functionality without hacking into the internal of slacker.</p>

<p>Like many server frameworks, slacker abstracts the request processing as a pipeline. The request object is modified by adding or updating attributes through each node of the pipeline. So it&#8217;s easy to add your interceptor into the pipeline, with which you can get the data before and after function executed.</p>

<p>To create such an interceptor, you should use the <em>slacker.interceptor/definterceptor</em> macro and <em>slacker.interceptor/definterceptor+</em> macro:</p>

<p><blockquote>(definterceptor name<br />
  :before interceptor-function<br />
  :after interceptor-function)</blockquote></p>

<p><blockquote>(definterceptor+ name [arguments]<br />
  :before interceptor-function<br />
  :after interceptor-function)</blockquote></p>

<p>definterceptor+ can accept arguments so you can configure the interceptor when you use it.</p>

<p>See a simple example:<br />
[cc lang=&#8221;clojure&#8221;]<br />
(definterceptor log-function-call<br />
  :before (fn [req] (println (str &#8220;calling &#8221; (:fname req))) req))</p>

<p>(definterceptor+ log-function-call-prefixed [prefix]<br />
  :before (fn [req] (println (str <br />
                               (if (fn? prefix) (prefix) prefix) <br />
                               &#8221; calling &#8221; <br />
                               (:fname req))) <br />
                    req))<br />
[/cc]</p>

<p>Then, add it to your slacker server by<br />
[cc lang=&#8221;clojure&#8221;]<br />
(use &#8216;[slacker.interceptor])<br />
(import &#8216;[java.util Date])<br />
(start-slacker (the-ns &#8216;slapi) 2104<br />
  :interceptors (interceptors log-function-call<br />
                              (log-function-call-prefixed <br />
                                (fn [] (.toString (Date.)))))<br />
[/cc]</p>

<p>Now you can log every function call of your slacker server.</p>

<p>For more detail about the interceptor framework, especially the request data, please check the <a href="https://github.com/sunng87/slacker/wiki/Interceptors" target="_blank">wiki page</a>.</p>

<p>In slacker 0.3.0, there is a built-in interceptor to stats function calls. You can find it at <em>slacker.interceptors.stats</em>. The stats data is expose via JMX. You can also write monitoring application to retrieve the data. 
<a href="http://imgur.com/vtOoL"><img src="http://i.imgur.com/vtOoL.png" alt="" title="Hosted by imgur.com" /></a></p>

<p>And there will be more built-in interceptors in 0.4.0, includes function call time stats and logging.</p>

<p></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2011/12/16/%E4%BD%BF%E7%94%A8clojure-thread-macro%E7%9A%84%E5%BF%83%E5%BE%97/">使用Clojure Thread Macro的心得</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-16T00:00:00+08:00" pubdate data-updated="true">Dec 16<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Thread Macro是clojure里一个很强大的宏，他帮助你简化嵌套函数的调用，比如<br />
[cc lang=&#8221;clojure&#8221;]<br />
(str (inc (count [:a :b])))<br />
[/cc]<br />
就可以利用thread macro简写成<br />
[cc lang=&#8221;clojure&#8221;]<br />
(-> [:a :b] count inc str)<br />
[/cc]</p>

<p>-&gt;&gt;和-&gt;类似，区别在于-&gt;&gt;把值作为函数的最后一个参数传入。</p>

<p>简单的功能介绍完了，接下来就遇到问题了。我需要功能，能够接受一个或多个函数，然后把这些函数组成一个pipeline。这时很自然想到-&gt;是一个好帮手。也许只需要一个类似这样的form就可以了： #(apply -&gt; % [funcs])。结果失败了，因为-&gt;是个宏，所以根本不能用apply。于是想到有apply-macro吗？有，或者说曾经有过。在contrib中曾经有一个apply-macro，不过被强烈不推荐使用。到这里，这条路堵死了，惟一的办法就是把-&gt;放到API之外，放到用户代码里去。</p>

<p>放到用户代码里，你需要写一个详细的说明文档并且告诉用户他必须这么做。然而在clojure世界里有一个更好的办法就是再写一个宏把-&gt;包装起来。这么做看似多此一举，其实是保持了API的一致性。通过宏，我们可以把自己的API延伸到用户代码中去。或者说，通过一个类似DSL的宏，给一些并不优雅的API一个缓冲，也为API日后的演化留下空间。</p>

<p>这里还要扯开一句关于宏的开发。clojure中所谓code is data，主要就是体现在宏里。原本在多数其他语言里，宏是不能求值的。但是在clojure里，由于code is data的缘故，宏是可以求值的。所有的输入数据都是list，你可以做first/reverse这样的操作。但是有一点要注意的是，宏中求得的值和代码里的值是不一样的。例如{:a inc}这样一个字面量，在宏里是可以通过:a做求值的，然后这里得到的并非一个函数（function），而是一个符号（symbol）。再者，调试宏的时候你可能会被这样的结果困惑：<br />
[cc lang=&#8221;clojure&#8221;]<br />
(defmacro a [f] (println (:a f)))<br />
(a {:a 1}) ; ==> prints 1<br />
(def b {:a 1})<br />
(a b) ; ==> prints nil<br />
[/cc]<br />
字面量可以，同值的变量就不行了。原因还是那句，宏里不能求值。</p>

<p>继续谈-&gt;。这个宏其实远没有你想象的那么驯服。遇到复杂一点的情况：<br />
[cc lang=&#8221;clojure&#8221;]<br />
(def m {:a inc})<br />
(-> 2 (get m :a) str)<br />
[/cc]<br />
这个写法对吗？str是个函数，(get m :a)返回的是inc也是个函数，貌似正确。运行之后却报错get的参数数量错误。所以千万不要忘了-&gt;是个宏，(get m :a)这里是不会求值到inc的，直接作为一个list被宏吞下去。在宏里只能通过符号的组合变化来生成代码，那么一不小心，就没有inc什么事了。</p>

<p>于是，你可能想到这里需要一个确切的函数，就好比这样：<br />
[cc lang=&#8221;clojure&#8221;]<br />
(def m {:a inc})<br />
(-> 2 (fn [x] ((get m :a) x)))<br />
[/cc]<br />
也许这样就好多了，我们放了一个匿名函数，并不要求宏去求值，因为这个匿名函数会被宏生成到新的代码里。里面的get也会在运行时求值。看似没什么问题，可是一运行还是没有期待的结果，居然返回了一个匿名函数！而对这个匿名函数求值得到的也是一个错误的结果！简直有点无厘头了。</p>

<p>呵呵，不故弄玄虚了。我们用macroexpand看看发生了什么。</p>

<p>这是用匿名函数包装以前<br />
[cc lang=&#8221;clojure&#8221;]<br />
(macroexpand-1 &#8216;(-> 2 (get m :a)))<br />
(get 2 m :a)<br />
[/cc]<br />
-&gt;居然只是简单地把2放到了get这个form里面！</p>

<p>再看看用匿名函数包装后的结果<br />
[cc lang=&#8221;clojure&#8221;]<br />
(macroexpand-1 &#8216;(-> 2 (fn [x] ((get m :a) x))))<br />
(fn 2 [x] ((get m :a) x))<br />
[/cc]<br />
和刚才一样，2被放到了第一个form的第一个参数位置！得到的是一个非法的form。</p>

<p>那么既然-&gt;只是简单地把第一个参数放到后面form的首个参数的位置，那么这个宏正确的使用方法其实是<br />
[cc lang=&#8221;clojure&#8221;]<br />
(def m {:a inc})<br />
(-> 2 ((fn [x] ((get m :a) x))))<br />
[/cc]<br />
再加一层括号！<br />
[cc lang=&#8221;clojure&#8221;]<br />
(macroexpand-1 &#8216;(-> 2 ((fn [x] ((get m :a) x)))))<br />
((fn [x] ((get m :a) x)) 2)<br />
[/cc]</p>

<p>可见，-&gt;虽然是个功能强大的宏，但宏终归只是宏，和函数的区别是明显的。在使用的时候，不能完全按照函数的习惯。</p>

<p>如果你想了解实际的代码，可以参考slacker 0.3.0里的这个interceptor框架：
<a href="https://github.com/sunng87/slacker/blob/master/src/slacker/interceptor.clj" target="_blank">https://github.com/sunng87/slacker/blob/master/src/slacker/interceptor.clj</a>
上面提到的难处，多半也都是在开发这个框架时亲身经历的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2011/12/10/slacker-0-2-0-is-out/">Slacker 0.2.0 Is Out</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-10T00:00:00+08:00" pubdate data-updated="true">Dec 10<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="https://github.com/sunng87/slacker">Slacker 0.2.0</a> has been pushed to clojars today. Connection pooling and json serialization are available in this release.</p>

<p><h4>Connection Pool</h4>
Generally, pooling connection is a good idea in high concurrence application. To make slacker for real world, connection pool support is a high-prioritized feature in its development. The new connection pool is backended by commons-pool which you might familiar with. To use connection pool, just create slacker client with a new function `slackerc-pool`</p>

<p>[cc lang=&#8221;clojure&#8221;]<br />
(def scp (slackerc-pool &#8220;localhost&#8221; 2104))<br />
[/cc]</p>

<p>Then you can use this pool just like a single client.</p>

<p>Some options are available to configure the pool by your wish:
<ul>
	<li><em>:max-active</em>, max connections opened by the pool</li>
	<li><em>:exhausted-action</em> <br />
            <ul>
               <li><em>:fail</em> throw an exception when pool exhausted.</li>
<li><em>:block</em> block current thread and wait until max-wait exceed (throw an exception)</li>
	<li><em>:grow</em> automatically create new connection and add it to pool</li></ul></li></ul></p>

<p>            
<li><em>:max-wait</em> max wait time before throwing an exception</li>
	<li><em>:min-idle</em> minimal number of pool hold idle connections </li></p>

<p>
The options are inherited from GenericObjectPool, you can find detailed information from their <a href="http://commons.apache.org/pool/apidocs/org/apache/commons/pool/impl/GenericObjectPool.html">javadoc</a>.</p>

<p><h4>JSON Serialization</h4>
slacker just added json serialization provided by clj-json. According to my test, clj-json is 1x faster than carbonite in serialization. <br />
[cc lang=&#8221;clojure&#8221;]<br />
(def sc (slackerc &#8220;localhost&#8221; 2104 :content-type :json))<br />
[/cc]</p>

<p>However, with json serialization, you may lost some clojure types like keyword and set in type conversion. You should be caution when using json as serialization method. </p>

<p>In next release, I am planning to use <a href="https://github.com/AlibabaTech/fastjson/" target="_blank">fastjson</a> as json lib which provides option to write type name into json so it could be a full featured serialization for clojure. And fastjson is claimed even faster than jackson.</p>

<p><h4>Performance</h4>
slacker gains high performance with its non-blocking server, serialization and direct function call. As tested on a dual 6 core server,  it reaches 10000+ TPS for a single client (50 connections, 50 threads). The server just use 35% CPU so I consider it could have even more TPS if there is two or more client machines.</p>

<p>So if you are interested in some benchmarks, you can test it with client like <a href="https://gist.github.com/1449860" target="_blank">this</a>. All the requests are using synchronous call because I believe it&#8217;s the most common case you use slacker.</p>

<p><h4>Next steps</h4>
Inspired by discussion in <a href="http://groups.google.com/group/cn-clojure" target="_blank">cn-clojure</a> mailing list, I&#8217;m going to add HTTP transport for slacker. With HTTP transport, it&#8217;s easier to debug and evaluate your clojure functions, it also makes slacker available to ClojureScript. </p>

<p>At lst, thanks Zach Tellman for reviewing my client code. 
</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2011/12/03/%E4%BB%8Egnome%E7%BD%91%E7%AB%99%E5%AE%89%E8%A3%85exaile-doubanfm-gnome-shell-extension/">从GNOME网站安装exaile-doubanfm-gnome-shell-extension</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-03T00:00:00+08:00" pubdate data-updated="true">Dec 3<span>rd</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近GNOME发布了期待已久的extension.gnome.org，这个网站允许你直接通过浏览器安装和管理gnome-shell扩展，有点类似app store的感觉，混乱的~/.local/share/gnome-shell/extensions/终于有了一个官方的界面。</p>

<p>网站开通的第一时间，我提交了exaile-doubanfm-gnome-shell-extension，经过review和修改，这个扩展也得到了进一步的完善，适配了gnome-shell 3.2的风格。</p>

<p>你可以从这个地址直接安装启用
<a href="https://extensions.gnome.org/extension/24/exaile-doubanfm-control/" target="_blank">https://extensions.gnome.org/extension/24/exaile-doubanfm-control/</a></p>

<p>它会在exaile douban.fm启动后显示一个菜单在gnome-shell上，你可以通过这个菜单进行基本的操作。</p>

<p>如果喜欢，别忘了在extension.gnome.org上vote一下 ：）</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2011/12/02/slacker-0-1-0-is-out/">Slacker 0.1.0 Is Out</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-02T00:00:00+08:00" pubdate data-updated="true">Dec 2<span>nd</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Glad to roll out the first release of the <strong>slacker</strong> framework. Slacker is a clojure RPC framework on top of a TCP binary protocol. It provides a set of non-invasive APIs for both server and client. The remote invocation is completely transparent to user.</p>

<p>In addition to APIs introduced in <a href="http://sunng.info/blog/2011/11/clojure-rpc-prototyping-and-early-thoughts/">last post</a>, asynchronous approach is supported in client API :<br />
[cc lang=&#8221;clojure&#8221;]<br />
(defremote remote-func :async true)<br />
@(remote-func)<br />
[/cc]<br />
If you add option `:async` to defremote, then the function facade will return a promise. You have to deref it by yourself. Also you can use the `:callback` option in defremote to specify a callback function.<br />
[cc lang=&#8221;clojure&#8221;]<br />
(defremote remote-func :callback #(println %))<br />
(remote-func)<br />
[/cc]</p>

<p>This gives you much more flexibility of using remote function. But be careful it will break consistency between local and remote mode. </p>

<p>To use slacker, add it to your project.clj<br />
[cc lang=&#8221;clojure&#8221;]<br />
:dependencies [[info.sunng/slacker &#8220;0.1.0&#8221;]]<br />
[/cc]</p>

<p>You can find examples on the <a href="https://github.com/sunng87/slacker" target="_blank">github page</a>. </p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/blog/2011/12/01/exaile%E8%B1%86%E7%93%A3%E7%94%B5%E5%8F%B0%E6%8F%92%E4%BB%B60-0-11%E5%8F%91%E5%B8%83/">Exaile豆瓣电台插件0.0.11发布</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-01T00:00:00+08:00" pubdate data-updated="true">Dec 1<span>st</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>很高兴时隔半年后我继续发布了Exaile豆瓣电台插件的更新，从第一个版本发布到现在已经有一年半的时间，这期间豆瓣电台插件已经陆续出现在Rhythmbox、Banshee等播放器上。作为第一个视图把豆瓣电台移植到本地的尝试，我感到甚是欣慰：）</p>

<p>这次的更新修正了长久依赖困绕用户登录问题，现在我们有一个专门的界面来输入验证码。这个功能要感谢<a href="https://github.com/sunng87/exaile-doubanfm-plugin/issues/8">DigitalPig</a>用户在github的报告（鞭策作用），此外，我参考了<a href="http://code.google.com/p/banshee-doubanfm/">豆瓣电台banshee插件</a>的实现，节省了研究含验证码登录的时间，感谢。总而言之，没有用户的推动，这个项目也不会坚持这么久。
<img src="http://i.imgur.com/cYNrM.png" alt="" /></p>

<p>除此之外，插件还有一些支持了新的豆瓣说的推荐，优化了播放列表载入的策略。</p>

<p>另外值得highlight的是，对应的gnome-shell扩展发布了0.0.2版本，唯一的更新是专辑封面现在会显示在gnome-shell的菜单中。
<img src="http://i.imgur.com/7Q1CP.jpg" alt="" /></p>

<p>你可以从github获得最新的插件和gnome-shell扩展：
<ul>
<li>exaile-doubanfm-plugin 0.0.11-captcha: <a href="https://github.com/sunng87/exaile-doubanfm-plugin/downloads">https://github.com/sunng87/exaile-doubanfm-plugin/downloads</a></li>
<li>exaile-doubanfm-gnome-shell-extension 0.0.2: <a href="https://github.com/sunng87/exaile-doubanfm-gnome-shell-extension/tarball/0.0.2">https://github.com/sunng87/exaile-doubanfm-gnome-shell-extension/tarball/0.0.2</a></li></ul></p>

<p>安装豆瓣电台插件请参考<a href="https://github.com/sunng87/exaile-doubanfm-plugin/wiki/Installation">这里</a>。gnome-shell扩展直接解压至~/.local/share/gnome-shell/extensions/即可
</p>

<p>有任何问题都可以在github或这里留言。
</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/blog/page/7/">&larr; Older</a>
    
    <a href="/blog/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/blog/page/5/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/blog/2013/07/16/four-years-as-programmer/">工作四周年</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2013/07/05/grunt-for-requirejs-projects/">Grunt for Requirejs Projects</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2013/06/29/%E7%BB%99-raspberry-pi-%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%98%BE%E7%A4%BA-ip-%E7%9A%84%E6%B6%B2%E6%99%B6%E5%B1%8F/">给 Raspberry Pi 添加一个显示 IP 的液晶屏</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2013/06/07/%E7%BA%B8%E4%B8%8A%E5%BE%97%E6%9D%A5%E7%BB%88%E8%A7%89%E6%B5%85/">纸上得来终觉浅</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2013/04/24/checkout-ring-adapter-for-jetty-9/">Checkout Ring Adapter for Jetty 9</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/sunng87">@sunng87</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'sunng87',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/blog/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>On Delicious</h1>
  <div id="delicious"></div>
  <script type="text/javascript" src="http://feeds.delicious.com/v2/json/classicing?count=3&amp;sort=date&amp;callback=renderDeliciousLinks"></script>
  <p><a href="http://delicious.com/classicing">My Delicious Bookmarks &raquo;</a></p>
</section>




  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Sun Ning -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'sunng-blog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
