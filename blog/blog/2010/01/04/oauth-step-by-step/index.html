<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>OAuth Step by Step</title>
  <meta name="description" content="最近琢磨OAuth认证方式。OAuth的优点主要在于﻿	用户不需要直接提供用户名密码给第三方应用，就可以让第三方应用访问受限资源；	资源提供方对第三方应用有更细粒度的控制。在整个OAuth协议里，生成signature的base string是最容易出错的部分。它由HTTP方法名、URL编码的请求路径和请求的参数...">

  <link rel="stylesheet" href="/blog/css/main.css">
  <link rel="canonical" href="http://sunng.info//blog/blog/2010/01/04/oauth-step-by-step/">
  <link rel="alternate" type="application/rss+xml" title="Here comes the Sun" href="http://sunng.info//blog/feed.xml" />
</head>

  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/blog/">Here comes the Sun</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

    </nav>

  </div>

</header>

    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">OAuth Step by Step</h1>
    <p class="post-meta">Jan 4, 2010</p>
  </header>

  <article class="post-content">
    <p>最近琢磨OAuth认证方式。OAuth的优点主要在于﻿
<ul>
	<li>用户不需要直接提供用户名密码给第三方应用，就可以让第三方应用访问受限资源；</li>
	<li>资源提供方对第三方应用有更细粒度的控制。</li>
</ul>
在整个OAuth协议里，生成signature的base string是最容易出错的部分。它由HTTP方法名、URL编码的请求路径和请求的参数表组成。<br />
请求的参数表是除去oauth_signature以外的所有参数，按参数名排序，并进行url转义
<pre class="brush:python">def to_signature_key(method, url, data):
	keys = list(data.keys())
	keys.sort()
	encoded = urllib.quote("&amp;".join([key+"="+data[key] for key in keys]))
	return "&amp;".join([method, urllib.quote(url, safe="~"), encoded])
</pre>
有了这个通用的生成signature base string的方法，以后就可以根据OAuth协议规范按步骤进行。</p>

<p>首先获取Request Token。这一步通常使用资源提供方注册的API Key和API Key Secret
<pre class="brush:python">def request_token_params(consumer_key, consumer_secret, path, method='GET'):
	data={}
	data['oauth_consumer_key']=consumer_key
	data['oauth_signature_method']='HMAC-SHA1'
	data['oauth_timestamp']=str(int(time.time()))
	data['oauth_nonce']=''.join([str(random.randint(0,9)) for i in range(10)])
	print data</pre></p>

<p>	msg = to_signature_key(method, path, data)<br />
	print msg</p>

<p>	signed = base64.b64encode(hmac.new(consumer_secret+"&amp;", msg, hashlib.sha1).digest())<br />
	print signed<br />
	data['oauth_signature']=signed<br />
	return data</p>

<p>def result2dict(result_string):<br />
	d = {}<br />
	params = res.split('&amp;')<br />
	for p in params:<br />
		d[p.split('=')[0]] = p.split('=')[1]<br />
	return d</p>

<p>conn = httplib.HTTPConnection("www.douban.com", 80)</p>

<p>params = request_token_params(consumer_key, consumer_secret, request_token_path)<br />
conn.request('GET', request_token_path+"?"+urllib.urlencode(params))<br />
res = conn.getresponse().read()<br />
print res<br />
request_token = result2dict(res)

这一步可以获得未经认证的Request Token和Request Token Secret。需要注意的细节是在计算hmac签名的时候，即使只有一个Token Secret，仍然需要加上"&amp;"</p>

<p>第二步要求用户授权该Request Token，打开浏览器，将用户定向到相应的授权页面，参数为上一步获得的Request Token</p>

<p>第三步，用授权过的Request Token换取Access Token。这一步类似第一步，只是用于签名的token包括API Key Secret和Request Token
<pre class="brush:python">def access_token_params(consumer_key, consumer_secret, oauth_token, oauth_secret, path, method='GET'):
	data={}
	data['oauth_consumer_key']=consumer_key
	data['oauth_signature_method']='HMAC-SHA1'
	data['oauth_timestamp']=str(int(time.time()))
	data['oauth_nonce']=''.join([str(random.randint(0,9)) for i in range(10)])
	data['oauth_token'] = oauth_token</pre></p>

<p>	msg = to_signature_key(method, path, data)<br />
	print msg</p>

<p>	signed = base64.b64encode(hmac.new(consumer_secret+"&amp;"+oauth_secret, msg, hashlib.sha1).digest())<br />
	print signed<br />
	data['oauth_signature']=signed<br />
	return data</p>

<p>params = access_token_params(consumer_key, consumer_secret, request_token['oauth_token'],<br />
	request_token['oauth_token_secret'], access_token_path)<br />
conn.request('GET', access_token_path+"?"+urllib.urlencode(params))<br />
res = conn.getresponse().read()<br />
print res<br />
access_token = result2dict(res)

这一步将至少返回Access Token和Access Token Secret，是最终用于访问受限资源的Token。以豆瓣的实现为例，OAuth的相关参数应放在HTTP头里随请求进行发送。
<pre class="brush:python">def oauth_header(consumer_key, consumer_secret, oauth_token, oauth_secret, path, realm):
	data = access_token_params(consumer_key, consumer_secret, oauth_token, oauth_secret, path, method="POST")
	header_string = ','.join([key+'="'+data[key]+'"' for key in data.keys()])
	return 'OAuth realm="'+realm+'",'+header_string</pre></p>

<p>posturl = 'http://api.douban.com/miniblog/saying'</p>

<p>content = """&lt;?xml version='1.0' encoding='UTF-8'?&gt;<br />
&lt;entry xmlns:ns0="http://www.w3.org/2005/Atom" xmlns:db="http://www.douban.com/xmlns/"&gt;<br />
&lt;content&gt;li lei ju le han mei mei&lt;/content&gt;<br />
&lt;/entry&gt;<br />
"""</p>

<p>header = {}<br />
header['Authorization'] = oauth_header(consumer_key, consumer_secret,<br />
		access_token['oauth_token'], access_token['oauth_token_secret'],<br />
		posturl, "http://api.douban.com")<br />
header['Content-Type'] = 'application/atom+xml'<br />
print header</p>

<p>conn.request('POST', posturl, content, header)<br />
res = conn.getresponse().read()</p>

<p>print res</p>

<p>conn.close()

在这一步中，用于生成signature base string的url是要访问的受限资源地址，而签名的参数表依然是oauth相关的参数。<br />
生成的Authorization头如下
<pre class="brush:text">Authorization: OAuth realm="http://api.douban.com",
    oauth_nonce="8735717688",
    oauth_timestamp="1262613619",
    oauth_consumer_key="0bc081a01168b263234184e0343a1729",
    oauth_signature_method="HMAC-SHA1",
    oauth_token="5fb836c37543ad691f28a44a5fcb083b",
    oauth_signature="jk6p5qaXVPrGQctSzpO5jjYHfDk="
</pre>
用这个头就可以在一定的时间内访问所有授权范围内的受限资源。</p>

<p>代码是ugly了一些，不过应该相对易于理解吧。</p>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Here comes the Sun</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Here comes the Sun</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text"></p>
      </div>
    </div>

  </div>

</footer>

  </body>

</html>
