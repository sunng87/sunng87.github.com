<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>使用Clojure Thread Macro的心得</title>
  <meta name="description" content="Thread Macro是clojure里一个很强大的宏，他帮助你简化嵌套函数的调用，比如[cc lang="clojure"](str (inc (count [:a :b])))[/cc]就可以利用thread macro简写成[cc lang="clojure"](-> [:a :b] count inc ...">

  <link rel="stylesheet" href="/blog/css/main.css">
  <link rel="canonical" href="http://sunng.info//blog/blog/2011/12/16/%E4%BD%BF%E7%94%A8clojure-thread-macro%E7%9A%84%E5%BF%83%E5%BE%97/">
  <link rel="alternate" type="application/rss+xml" title="Here comes the Sun" href="http://sunng.info//blog/atom.xml" />
</head>

  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/blog/">Here comes the Sun</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

    </nav>

  </div>

</header>

    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">使用Clojure Thread Macro的心得</h1>
    <p class="post-meta">Dec 16, 2011</p>
  </header>

  <article class="post-content">
    <p>Thread Macro是clojure里一个很强大的宏，他帮助你简化嵌套函数的调用，比如<br />
[cc lang="clojure"]<br />
(str (inc (count [:a :b])))<br />
[/cc]<br />
就可以利用thread macro简写成<br />
[cc lang="clojure"]<br />
(-> [:a :b] count inc str)<br />
[/cc]</p>

<p>-&gt;&gt;和-&gt;类似，区别在于-&gt;&gt;把值作为函数的最后一个参数传入。</p>

<p>简单的功能介绍完了，接下来就遇到问题了。我需要功能，能够接受一个或多个函数，然后把这些函数组成一个pipeline。这时很自然想到-&gt;是一个好帮手。也许只需要一个类似这样的form就可以了： #(apply -&gt; % [funcs])。结果失败了，因为-&gt;是个宏，所以根本不能用apply。于是想到有apply-macro吗？有，或者说曾经有过。在contrib中曾经有一个apply-macro，不过被强烈不推荐使用。到这里，这条路堵死了，惟一的办法就是把-&gt;放到API之外，放到用户代码里去。</p>

<p>放到用户代码里，你需要写一个详细的说明文档并且告诉用户他必须这么做。然而在clojure世界里有一个更好的办法就是再写一个宏把-&gt;包装起来。这么做看似多此一举，其实是保持了API的一致性。通过宏，我们可以把自己的API延伸到用户代码中去。或者说，通过一个类似DSL的宏，给一些并不优雅的API一个缓冲，也为API日后的演化留下空间。</p>

<p>这里还要扯开一句关于宏的开发。clojure中所谓code is data，主要就是体现在宏里。原本在多数其他语言里，宏是不能求值的。但是在clojure里，由于code is data的缘故，宏是可以求值的。所有的输入数据都是list，你可以做first/reverse这样的操作。但是有一点要注意的是，宏中求得的值和代码里的值是不一样的。例如{:a inc}这样一个字面量，在宏里是可以通过:a做求值的，然后这里得到的并非一个函数（function），而是一个符号（symbol）。再者，调试宏的时候你可能会被这样的结果困惑：<br />
[cc lang="clojure"]<br />
(defmacro a [f] (println (:a f)))<br />
(a {:a 1}) ; ==> prints 1<br />
(def b {:a 1})<br />
(a b) ; ==> prints nil<br />
[/cc]<br />
字面量可以，同值的变量就不行了。原因还是那句，宏里不能求值。</p>

<p>继续谈-&gt;。这个宏其实远没有你想象的那么驯服。遇到复杂一点的情况：<br />
[cc lang="clojure"]<br />
(def m {:a inc})<br />
(-> 2 (get m :a) str)<br />
[/cc]<br />
这个写法对吗？str是个函数，(get m :a)返回的是inc也是个函数，貌似正确。运行之后却报错get的参数数量错误。所以千万不要忘了-&gt;是个宏，(get m :a)这里是不会求值到inc的，直接作为一个list被宏吞下去。在宏里只能通过符号的组合变化来生成代码，那么一不小心，就没有inc什么事了。</p>

<p>于是，你可能想到这里需要一个确切的函数，就好比这样：<br />
[cc lang="clojure"]<br />
(def m {:a inc})<br />
(-> 2 (fn [x] ((get m :a) x)))<br />
[/cc]<br />
也许这样就好多了，我们放了一个匿名函数，并不要求宏去求值，因为这个匿名函数会被宏生成到新的代码里。里面的get也会在运行时求值。看似没什么问题，可是一运行还是没有期待的结果，居然返回了一个匿名函数！而对这个匿名函数求值得到的也是一个错误的结果！简直有点无厘头了。</p>

<p>呵呵，不故弄玄虚了。我们用macroexpand看看发生了什么。</p>

<p>这是用匿名函数包装以前<br />
[cc lang="clojure"]<br />
(macroexpand-1 '(-> 2 (get m :a)))<br />
(get 2 m :a)<br />
[/cc]<br />
-&gt;居然只是简单地把2放到了get这个form里面！</p>

<p>再看看用匿名函数包装后的结果<br />
[cc lang="clojure"]<br />
(macroexpand-1 '(-> 2 (fn [x] ((get m :a) x))))<br />
(fn 2 [x] ((get m :a) x))<br />
[/cc]<br />
和刚才一样，2被放到了第一个form的第一个参数位置！得到的是一个非法的form。</p>

<p>那么既然-&gt;只是简单地把第一个参数放到后面form的首个参数的位置，那么这个宏正确的使用方法其实是<br />
[cc lang="clojure"]<br />
(def m {:a inc})<br />
(-> 2 ((fn [x] ((get m :a) x))))<br />
[/cc]<br />
再加一层括号！<br />
[cc lang="clojure"]<br />
(macroexpand-1 '(-> 2 ((fn [x] ((get m :a) x)))))<br />
((fn [x] ((get m :a) x)) 2)<br />
[/cc]</p>

<p>可见，-&gt;虽然是个功能强大的宏，但宏终归只是宏，和函数的区别是明显的。在使用的时候，不能完全按照函数的习惯。</p>

<p>如果你想了解实际的代码，可以参考slacker 0.3.0里的这个interceptor框架：
<a href="https://github.com/sunng87/slacker/blob/master/src/slacker/interceptor.clj" target="_blank">https://github.com/sunng87/slacker/blob/master/src/slacker/interceptor.clj</a>
上面提到的难处，多半也都是在开发这个框架时亲身经历的。</p>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Here comes the Sun</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Here comes the Sun</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text"></p>
      </div>
    </div>

  </div>

</footer>

  </body>

</html>
