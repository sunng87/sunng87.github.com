<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rust | Here comes the Sun]]></title>
  <link href="http://sunng87.github.io/blog//blog/categories/rust/atom.xml" rel="self"/>
  <link href="http://sunng87.github.io/blog//"/>
  <updated>2014-08-02T19:45:23+08:00</updated>
  <id>http://sunng87.github.io/blog//</id>
  <author>
    <name><![CDATA[Sun Ning]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在 Docker 中安装和使用 Rust Nightly 版本]]></title>
    <link href="http://sunng87.github.io/blog//blog/2014/08/02/rust-with-docker/"/>
    <updated>2014-08-02T18:02:12+08:00</updated>
    <id>http://sunng87.github.io/blog//blog/2014/08/02/rust-with-docker</id>
    <content type="html"><![CDATA[<p>一直关注 Rust 语言，最近一下发现了两个 web 框架，<a href="http://ironframework.org">Iron</a> 和 <a href="http://nickel.rs">Nickel.rs</a>。先不说这两个框架成熟度如何，一般情况下，一个语言有了 web 框架，算是一个里程碑，说明他离靠谱也不远了。这样我决定跟一下 nightly 版本（新框架都是跟 nightly），另外也能感受一下 <a href="https://mail.mozilla.org/pipermail/rust-dev/2014-March/009090.html">Yehuda Katz 的构建工具 Cargo</a>。ArchLinux 的仓库里已经有 0.11 版本，再用脚本安装必然会有冲突。于是想到了最近半年<a href="https://twitter.com/jessenoller/status/495037475421954048">最火的 Docker</a>，可以轻松的创建多个环境，正是一个非常好的场景。</p>

<h2>安装</h2>

<p>安装 Docker, Arch Linux 仓库里很早就有，非常方便：<code>sudo pacman -S docker</code>。完成之后启动他：<code>sudo systemctl start docker</code>。</p>

<p>之后我们拉一个 ubuntu 的镜像下来：<code>docker pull ubuntu</code>。</p>

<p>完成之后，我们启动一个 container，做一些基本的 setup：<code>docker run -i -t ubuntu:14.04 /bin/bash</code></p>

<p>这相当与运行在 ubuntu:14.04 这个镜像上运行一个 shell，接下来就进入了这个 shell 环境，和 ubuntu 安装版本完全一致，我们做一些基础的准备，安装一些必要的工具：<code>apt-get install build-essentials git curl libssl-dev</code></p>

<p>之后，就可以下载 Rust 提供的脚本来安装 nightly 版本了：<code>curl -s http://www.rust-lang.org/rustup.sh &gt; rustup</code></p>

<p>这里有个问题，rustup 脚本判断64位系统时会出错导致安装失败：
```sh</p>

<h1>Detect 64 bit linux systems with 32 bit userland and force 32 bit compilation</h1>

<p>if [ $CFG_OSTYPE = unknown-linux-gnu -a $CFG_CPUTYPE = x86_64 ]
then</p>

<pre><code>file -L "$SHELL" | grep -q "x86[_-]64"
if [ $? != 0 ]; then
    CFG_CPUTYPE=i686
fi
</code></pre>

<p>fi
```</p>

<p>因为在我的机器上已知系统是64位，就强行绕过了他的判断。</p>

<p>```bash
if [ $CFG_OSTYPE = unknown-linux-gnu -a $CFG_CPUTYPE = x86_64 ]
then</p>

<pre><code>file -L "$SHELL" | grep -q "x86[_-]64"
if [ $? == 0 ]; then
    CFG_CPUTYPE=i686
fi
</code></pre>

<p>fi
```</p>

<p>之后执行 rustup 就可以直接安装最近的 rustc 和 cargo 了。安装完成执行 <code>rustc -v</code> 和 <code>cargo --version</code> （两个工具还不统一！）可以了解安装情况。</p>

<p>exit 退出 shell，commit 你的镜像，这样一个干净的镜像要好好保存：<code>docker commit IMAGE_ID sunng/rust-nightly</code></p>

<h2>Hello World</h2>

<p>之后可以写点代码了，我们不在 docker 里写，我们在 host 机器上写，然后挂载到 docker 上，因此 emacs 什么的也不用配置了。</p>

<p>创建一个目录，比如在 <code>$HOME/var/docker/helloworld</code>下，最简单的 rust 项目只要两个文件： <code>Cargo.toml</code> 和 <code>src/main.rs</code>。</p>

<p>```</p>

<h1>Cargo.toml</h1>

<p>[package]</p>

<p>name = &ldquo;hello-world&rdquo;
version = &ldquo;0.1.0&rdquo;
authors = [ &ldquo;<a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x73;&#117;&#110;&#110;&#x67;&#x40;&#97;&#98;&#111;&#x75;&#116;&#x2e;&#x6d;&#x65;">&#x73;&#117;&#x6e;&#x6e;&#x67;&#64;&#97;&#98;&#x6f;&#x75;&#116;&#x2e;&#109;&#x65;</a>&rdquo; ]
```</p>

<p>```rust
//main.rs</p>

<p>fn main() {
  println!(&ldquo;hello world&rdquo;);
}</p>

<p>```</p>

<p>构建项目不需要手动 rustc 了，那是上个世纪的东西，我们直接 <code>cargo build</code> 就可以：<code>docker run -i -t -v $HOME/var/docker:/mnt/data -w /mnt/data/helloworld sunng/nightly cargo build</code></p>

<p>其中 <code>-v</code> 参数用于挂载目录，<code>-w</code> 参数指定执行的 pwd。</p>

<p>如果构建成功，就可以执行了，在 docker 中执行：<code>docker run -i -t -v $HOME/var/docker:/mnt/data -w /mnt/data/helloworld sunng/nightly target/hello-world</code></p>

<p>其实可以直接在 host 系统里执行也是完全可以的：<code>$HOME/var/docker/helloworld/target/hello-world</code>。</p>

<h2>Web Hello World</h2>

<p>前面说了 Rust 都有 web 框架了，我们就写一个 Web 版本的 Hello World 吧。这次用 Iron 框架，首先添加依赖到 Cargo 文件：</p>

<p>```
[package]</p>

<p>name = &ldquo;hello-world&rdquo;
version = &ldquo;0.1.0&rdquo;
authors = [ &ldquo;<a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x73;&#117;&#x6e;&#x6e;&#103;&#64;&#97;&#x62;&#x6f;&#x75;&#x74;&#x2e;&#109;&#101;">&#115;&#117;&#110;&#110;&#x67;&#x40;&#97;&#x62;&#x6f;&#117;&#x74;&#x2e;&#x6d;&#x65;</a>&rdquo; ]</p>

<p>[dependencies.iron]</p>

<p>git = &ldquo;<a href="https://github.com/iron/iron.git">https://github.com/iron/iron.git</a>&rdquo;</p>

<p>[dependencies.core]</p>

<p>git = &ldquo;<a href="https://github.com/iron/core.git">https://github.com/iron/core.git</a>&rdquo;
```</p>

<p>Cargo 目前还没有中央仓库，但是<a href="http://crates.io/faq.html#github">据说将来会有</a>。目前还都是用 git 仓库来直接添加，所以构建环境里必须要有 git。</p>

<p>照着 <a href="https://github.com/iron/iron/blob/master/examples/hello.rs">Iron 的例子</a>写一个最简单的 hello world 程序。</p>

<p>```rust
extern crate iron;
extern crate http;</p>

<p>use std::io::net::ip::Ipv4Addr;
use iron::{Iron, Server, Chain, Request, Response, Alloy, Status, Unwind, FromFn};
use <a href="http::status;">http::status;</a></p>

<p>fn hello_world(<em>: &amp;mut Request, res: &amp;mut Response, </em>: &amp;mut Alloy) &ndash;> Status {</p>

<pre><code>res.serve(status::Ok, "Hello, world!");
Unwind
</code></pre>

<p>}</p>

<p>fn main() {
  let mut server: Server = Iron::new();
  server.chain.link(FromFn::new(hello_world));
  server.listen(Ipv4Addr(127, 0, 0, 1), 3000);
}</p>

<p>```</p>

<p>编译 <code>docker run -i -t -v $HOME/var/docker:/mnt/data -w /mnt/data/helloworld sunng/nightly cargo build</code></p>

<p>运行 <code>docker run -i -t -v $HOME/var/docker:/mnt/data -w /mnt/data/helloworld -p 3000:3000 sunng/nightly target/hello-world</code></p>

<p>新增的参数<code>-p</code>是把 docker 环境里的端口3000映射到 host 上的3000，这样我们才能在外面访问。</p>

<p>最后还有一个问题，因为程序听的是127.0.0.1，所以在 host 上是无法访问这个端口的，修改代码：</p>

<p>```rust</p>

<p>  server.listen(Ipv4Addr(0, 0, 0, 0), 3000);
```</p>

<p>就可以正常工作了。</p>

<h2>Wrap up</h2>

<p>总结一下上面用 docker 比虚拟机的好处：</p>

<ul>
<li>占用资源少，启动快</li>
<li>与 host 共享网络、硬盘都非常方便，满足开发需要不成问题</li>
<li>所有都是命令，与 host 系统上的进程集成也非常方便</li>
<li>支持镜像的版本控制和仓库</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rust语言：安全的并发]]></title>
    <link href="http://sunng87.github.io/blog//blog/2014/04/20/rust-concurrent-made-safely/"/>
    <updated>2014-04-20T16:31:54+08:00</updated>
    <id>http://sunng87.github.io/blog//blog/2014/04/20/rust-concurrent-made-safely</id>
    <content type="html"><![CDATA[<p>本文原载于2014年3月《程序员》杂志编程语言专题。</p>

<p>Rust 语言是近两年来 Mozilla 正在开发的一种新编程语言，它以并发，安全和实用为口号，主要使用场景是系统编程，用来取代C++语言的角色。有人戏称 Mozilla 由于大量使用 C++，深知其弊端，所以诞生了 Rust。目前，Rust 的两个主要产品是 Mozilla 下一代的浏览器布局引擎 Servo 和 Rust 编译器。由于语言在快速的开发和演进中，每个版本都会产生一些不兼容的变更，所以现在并非是学习这门语言细节并真正使用它的最佳时机。不过，这并不影响我们了解 Rust 语言：作为多年来鲜有的新系统编程语言，他本身有很多新颖之处，也可以帮助我们了解一些编程语言设计的流行趋势。</p>

<h2>并发</h2>

<p>和现在流行的很多新语言一样，Rust 在语言层面支持了绿色线程（Green threads）：Task。Task 作为并发执行的单元，是用户空间的“线程”，创建和调度成本较低，可以大量共存。Task之间通过消息传递通信，没有直接的共享数据。从最近的流行趋势来看，绿色线程几乎已经成为并发方案大战最终的赢家。除了Rust，之前流行的Go语言，Erlang，Python的Gevent，以及最近Clojure世界里正在发展的core.async，采用的都是这种绿色线程的模式。</p>

<p>绿色线程的程序与传统多线程程序的写法几乎一致。在编写服务器程序时，与事件驱动的回调机制相比，编写更简单，表义更清晰。当并发任务增多时，传统的多线程程序由于启动线程和调度线程的成本高而使系统整体性能降低。而绿色线程可以基本不受限制，随意创建。Rust的文档指出在32位系统上可以支持数十万个Task同时存在。</p>

<p>Task也是Rust程序的基础单元，一个Rust进程又多个并行的task组成，main函数本身也是一个Task。Task之间通过一个 (Port, Chan) 元组传递数据。Port和Chan相当于管道的两端，Port用于取数据，Chan用于发送数据。下面的例子里，我们通过do spawn语法（类似Ruby的block语法），启动一个新Task，并打印收到的数据。</p>

<p>``` rust
fn main(){
  let msg = &ldquo;hello world&rdquo;;
  let (port, chan) = Chan::new();</p>

<p>  chan.send(msg);</p>

<p>  do spawn {</p>

<pre><code>let received_msg = port.recv(); 
println(received_msg); 
</code></pre>

<p>  }
}</p>

<p>```</p>

<h2>引用系统</h2>

<p>Rust 语言设计的核心是安全性（这里安全性指safety，而非 security）。Rust 希望通过语言的机制和编译器的功能，把程序员易于犯错，不易检查的问题解决在编译期，避免运行时的Segmentation Fault。Rust 的设计可以说是处处小心。Clojure语言强调可变性给编程带来的复杂性，在 Rust 语言中，设计者对这点也有格外的重视。除非特别声明为 mut，所有 Rust 的局部变量默认都是不可变的，对不可变变量值的修改会导致 编译器直接报错。</p>

<p>Rust 的安全性还通过独有的引用类型系统来实现。</p>

<p>Rust 语言中堆内存块的引用类型叫做box。最新版本的Rust 在语言层面只保留了一种owned box，它在使用时具有一种所有权（ownership）的概念，只有具有所有权的变量才可以访问这段内存。Owned box在同一时刻只允许一个变量作为所有者，它的变量赋值称为move。一旦owned pointer被赋值，用户就无法通过原先的引用访问这块数据，这种错误会在编译时检查。
一个简单的例子：</p>

<p>``` rust
fn main() {</p>

<pre><code>let a: ~int = ~50;
let b: ~int = a;
println!("{:?}", *a);
</code></pre>

<p>}
```</p>

<p>~ 代表owned box，这里我们把一个包含值为50的owned box赋给owned pointer a。然后把a的所有权通过赋值的形式move给b。最后我们试图通过 <code>*a</code> 访问这个值。在C语言里，这时a和b同时指向统一块内存，可以通过<code>*a</code>访问到这里的值。但Rust的所有权机制给予了这段内存额外的保护。编译这段程序将失败：</p>

<p><code>``
own.rs:4:23: 4:24 error: use of moved value:</code>a`
own.rs:4     println!(&ldquo;{:?}&rdquo;, *a);</p>

<pre><code>                           ^
</code></pre>

<p>&hellip;
own.rs:3:9: 3:10 note: <code>a</code> moved here because it has type <code>~int</code>, which is moved by default (use <code>ref</code> to override)
own.rs:3     let b: ~int = a;</p>

<pre><code>             ^
</code></pre>

<p>```
编译器会明确地指出错误的引用在何处被move。事实上所有owned box的生命周期管理都是直接在编译时完成的，编译器通过静态检查跟踪使用情况，完成内存开辟和回收。这是Rust 确保编程正确、安全的重要手段。</p>

<p>新版本的Rust在标准库中提供 <code>std::rc::Rc</code>（引用计数） 和 <code>std::gc::Gc</code> （垃圾回收）类型，取代了原先的managed box，用来提供可以有限共享的引用类型。</p>

<p>在 Task 间传递数据，如果要避免数据拷贝，也有专门的引用类型：用于不可变数据的<code>extra::arc::Arc</code> (atomically reference counted ，原子的引用计数类型) , 以及用于可变数据的 RWArc（带读写锁的原子引用计数类型） 。RWArc在操作可变数据时，通过内在的读写锁控制对共享数据的访问，从而在API层面实现安全性。</p>

<p>``` rust
extern mod extra;
use extra::arc::{RWArc};</p>

<p>fn main() {</p>

<pre><code>let s = ~"hello world";
let arc_ref = RWArc::new(s);

for i in range(0, 10) {
    let (port, chan) = Chan::new();
    chan.send(arc_ref.clone());

    do spawn {
        let arc_local_ref = port.recv();

        arc_local_ref.write(|str| {
            str.push_char('!');
        });

        arc_local_ref.read(|str| {
            println(*str);
        });
    }
}
</code></pre>

<p>}
```</p>

<p>Rust谨慎地定义如此繁多，各具功能的引用类型，就是希望用户在编程过程中，根据应用场景、引用的功能职责，选择合适的类型，进而在引用类型系统和编译器的保护下，减少在运行时出错的机会。这一点也和Clojure的4种引用类型的设计初衷类似，不过Clojure并不能提供太多编译时的安全保护。</p>

<h2>更多</h2>

<p>篇幅所限，我只选择了Rust最具特点的两个部分介绍。Rust是一门具备自身显著特点，精心设计的语言，而绝非普通的“又一门编程语言”。在语法层面，它包含了模式匹配，闭包，泛型等流行功能，作为系统编程语言，使用的舒适度不亚于脚本语言。另外还可以通过FFI（Foreign Function Interface）调用已有的C语言库，满足了实用性的需要。</p>

<p>如果你也开始对这门新语言感兴趣，可以：</p>

<ul>
<li>通过<a href="http://static.rust-lang.org/doc/master/tutorial.html">它的文档</a>学习最新版本的语法和细节</li>
<li>加入<a href="https://mail.mozilla.org/listinfo/rust-dev">rust-dev邮件列表</a>了解开发者的讨论</li>
<li>关注<a href="https://github.com/mozilla/rust">Rust项目代码仓库</a></li>
<li>关注<a href="https://delicious.com/tag/rust">Delicious</a> 和 <a href="http://www.reddit.com/r/rust">Reddit</a> 上流行的 rust 链接</li>
<li>关注<a href="http://cmr.github.io/">The week in Rust</a>，介绍每周 Rust 语言正在发生的变化</li>
</ul>

]]></content>
  </entry>
  
</feed>
