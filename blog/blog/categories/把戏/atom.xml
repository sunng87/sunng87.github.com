<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Here comes the Sun</title>
  <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/"/>
  <link rel="self" type="application/atom+xml" href="http://sunng87.github.io/blog/blog/blog/categories/把戏/atom.xml"/>
  <id>http://sunng87.github.io/blog/blog/</id>
  <updated>2013-06-29T00:00:00+08:00</updated>
  <generator uri="http://octopress.org/">Octopress</generator>
  
  <rights>Copyright © 2015, Sun Ning</rights>

  <entry>
    <title type="html">给 Raspberry Pi 添加一个显示 IP 的液晶屏</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2013/06/29/%E7%BB%99-raspberry-pi-%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%98%BE%E7%A4%BA-ip-%E7%9A%84%E6%B6%B2%E6%99%B6%E5%B1%8F/"/>
    
    <id>/blog/2013/06/29/给-raspberry-pi-添加一个显示-ip-的液晶屏</id>
    <published>2013-06-29T00:00:00+08:00</published>
    <updated>2013-06-29T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>我的 Raspberry Pi 在家里一直是通过 DHCP 联网的，每次要登录上去都要先进路由管理界面看看他的 IP 到底是什么，很不方便。于是就买了这块液晶屏幕，准备显示一下 IP，另外以后也可以作为一个输出设备。毕竟用这个比外接一个显示器方便多了（现在显示器最小都是21寸）。</p>

<p>液晶屏就是最普通的1602屏幕，淘宝上有很多，基本上都一样。要注意的是需要自备引脚，要自己焊到板上，否则无法连接。我也是第一回焊，感觉还比较简单。(<a href="http://instagram.com/p/bIPSEcBM6R/" target="_blank">如图。</a>)另外为了控制液晶屏的对比度需要有一个电位器，为此我中途还专门跑了一趟中关村。</p>

<p>之后就可以按照 <a href="http://learn.adafruit.com/drive-a-16x2-lcd-directly-with-a-raspberry-pi/overview" target="_blank">Adafruit 上的教程</a>一步一步做了。</p>

<p>最后我简化了一下显示 IP 的脚本，时间就不去刷新了。
<script src="https://gist.github.com/sunng87/5890563.js"></script></p>

<p>把这个脚本作为 systemd 的服务，可以参考<a href="http://blog.sdbarker.com/adding-custom-units-services-to-systemd-on-arch-linux/" target="_blank">这里</a>有关如何创建自定义服务的说明。然后通过systemctl enable ip-display.service设置自启动。</p>

<p>最终效果如下：
<img src="http://i.imgur.com/ZqAc2dh.jpg" alt="my ip display setup" /></p>

<p></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">第一个开关</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2013/02/23/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BC%80%E5%85%B3/"/>
    
    <id>/blog/2013/02/23/第一个开关</id>
    <published>2013-02-23T00:00:00+08:00</published>
    <updated>2013-02-23T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p><img src="http://i.imgur.com/3S4WPUG.jpg" alt="" /></p>

<p>过年回家路上无聊看了一些关于电子制作的书，知道了 Android 上的开发板 IOIO。另外认识了 Arduino 的程序，感觉要比想象中还要简单。本来担心还要学一门新的语言，看了之后发现完全是多虑。</p>

<p>在淘宝上找 IOIO 的时候正好发现了<a href="http://item.taobao.com/item.htm?id=13115078082">一整套元件</a>。买回来以后看看可能价格是贵了，但是对我这样的新手来说，省去了自己找元件的麻烦。因为找元件实在是很容易让人退缩。</p>

<p>点亮 Arduino 基本上没什么问题。但是在 Archlinux 上访问 serial port 需要一些配置。首先要把用户加入 uucp 组确保可以访问 /dev/tty* 的设备。其次，需要给当前用户访问 /run/lock 的权限，否则 Arduino IDE 还是无法访问到 Arduino，这点在 Archlinux 的 Wiki 上有提及。</p>

<p>我这个开关电路太简单了就不详细说了，参考书是一本 Getting started with Arduino。据说这本书出第二版了，第一版上 Arduino 的版本不是 Uno，所以图片有一些出入，不过接口都没有变化。这第一个二极管开关的电路还是挺有成就感的，晚上我就可以让台灯什么的都退了休吧。</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Top Github Users in China</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2012/07/19/top-github-users-in-china/"/>
    
    <id>/blog/2012/07/19/top-github-users-in-china</id>
    <published>2012-07-19T00:00:00+08:00</published>
    <updated>2012-07-19T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>有感于<a href="http://sofish.de/file/demo/github/" target="_blank">这个版本</a>的github中国用户排名，我觉得单纯根据用户的followers数量不能完全说明问题。因此，需要改进一下排名的分数，加入项目Watchers的数量，这样可以让优质项目多的用户排名到前面。</p>

<p>这个策略是：followers + 1.5 * watchers + 2 * forks</p>

<p>得到的排名如下：
<script src="https://gist.github.com/3141146.js?file=results"></script></p>

<p>另外，这前100名用户里，语言使用的情况如下：<br />
'JavaScript': 80<br />
'Ruby': 52<br />
'Python': 46<br />
'C': 34<br />
'C++': 30<br />
'Java': 28<br />
'VimL': 28<br />
'Shell': 24<br />
'Objective-C': 24<br />
'PHP': 21<br />
'CoffeeScript': 13<br />
'Perl': 10<br />
'Erlang': 9<br />
'Emacs Lisp': 9<br />
'Lua': 6<br />
'Haskell': 5<br />
'Clojure': 5<br />
'Go': 5<br />
'ActionScript': 4<br />
'C#': 3<br />
'Scheme': 2<br />
'Common Lisp': 2<br />
'Elixir': 2<br />
'Scala': 1<br />
'Objective-J': 1<br />
'Vala': 1<br />
'Nemerle': 1</p>

<p>明天我会补充一下城市的排名。</p>

<p></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Visualizing OpenStreetMap Nanjing Contribution</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2012/04/20/visualizing-openstreetmap-nanjing-contribution/"/>
    
    <id>/blog/2012/04/20/visualizing-openstreetmap-nanjing-contribution</id>
    <published>2012-04-20T00:00:00+08:00</published>
    <updated>2012-04-20T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>早上在prismatic上看到mapbox的一篇<a href="http://mapbox.com/blog/how-to-map-contributions-openstreetmap/" target="_blank">博客</a>，介绍通过TileMill可视化OSM的贡献者，非常酷。于是我在南京的地图上也做了一个这样的可视化。</p>

<p><img src="http://i.imgur.com/U2yXK.png" alt="" /></p>

<p>一个详细的大图在<a href="http://i.imgur.com/YnULm.png" target="_blank">这里</a>。虽然只做了南京的五个主要贡献者，基本上涵盖了大部分数据。</p>

<p>图例就不专门输出了<br />
[user = 'Sunng'] { marker-fill: @magenta;} <br />
[user = 'fuwuyuan'] { marker-fill: @blue;}<br />
[user = 'sinopitt'] {marker-fill: @yellow;}<br />
[user = 'larryy'] {marker-fill: @green;}<br />
[user = 'zhengz'] {marker-fill: @red;}</p>

<p>MapBox家的东西真的非常酷，这家的技术以nodejs为主，围绕osm开发了不少产品。最近比较大的新闻，比如4sq转到osm上，其实就是转到这家的osm服务上。有兴趣你可以关注一下！
<img src="http://i.imgur.com/Hum2r.png" alt="" /></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">为WebWorker设置正确的路径</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2012/03/22/%E4%B8%BAwebworker%E8%AE%BE%E7%BD%AE%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    
    <id>/blog/2012/03/22/为webworker设置正确的路径</id>
    <published>2012-03-22T00:00:00+08:00</published>
    <updated>2012-03-22T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>WebWorker的路径通常是写在代码源文件中，而且这个路径并非其相对父js文件的相对路径，而似乎是相对页面的路径。所以指定一个正确的可随处部署的路径变得有些麻烦。昨天有人给HeatCanvas提了这个问题我才想到上网搜索了一下，有一个还算挺不错的办法。</p>

<p>写一个getPath函数，从document里找到父js的路径，拼到Worker的名字上。对heatcanvas.js这个文件来说就是：</p>

<p>[cc lang="javascript"]<br />
HeatCanvas.getPath = function() {<br />
    var scriptTags = document.getElementsByTagName("script");<br />
    for (var i=0; i<scriptTags.length; i++) {<br />
        var src = scriptTags[i].src;<br />
        var pos = src.indexOf("heatcanvas.js");<br />
        if (pos > 0) {<br />
            return src.substring(0, pos);<br />
        }<br />
    }<br />
    return "";<br />
};<br />
[/cc]</p>

<p>因此现在HeatCanvas已经解决了这个路径问题，现在这个库应该更好用了。当然如果你改了我的文件名我就无话可说了。
</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Visualize Reddit Upvotes by Subreddit</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/10/27/visualize-reddit-upvotes-by-subreddit/"/>
    
    <id>/blog/2011/10/27/visualize-reddit-upvotes-by-subreddit</id>
    <published>2011-10-27T00:00:00+08:00</published>
    <updated>2011-10-27T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>这是我reddit上所有的upvote在各个subreddit上的分布情况，这个情况还是可以说明我是个普通青年。
<img src="http://i.imgur.com/jfXyK.png" alt="Reddit upvotes visualization" width="500px" /></p>

<p>排在前几位的分别是
<ul>
	<li>Programming</li>
	<li>Linux</li>
	<li>Python</li>
	<li>f7u12</li>
	<li>Clojure</li>
	<li>Ubuntu</li>
</ul></p>

<p>如果你还不了解什么是Reddit：Reddit是一个巨大的社会书签+论坛网站，他的频道叫做subreddit，每个频道有一个相应的主题，涵盖了从IT技术到新闻到生活的各个角落。</p>

<p>这些数据是通过下面的Clojure程序获得（使用reddit.clj库），并通过jfreechart展现出来的。
<script src="https://gist.github.com/1315572.js"> </script>
</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Substract a Vector From a Matrix in Octave</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/10/21/substract-a-vector-from-a-matrix-in-octave/"/>
    
    <id>/blog/2011/10/21/substract-a-vector-from-a-matrix-in-octave</id>
    <published>2011-10-21T00:00:00+08:00</published>
    <updated>2011-10-21T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>假设你有一个矩阵：</p>

<p>[cc lang="text"]<br />
A = [1,2;3,4;5,6]<br />
[/cc]</p>

<p>以及一个矢量：</p>

<p>[cc lang="text"]<br />
B = [2,5]<br />
[/cc]</p>

<p>你希望对A的每一行元素对元素地减B，例如第一行<br />
[cc lang="text"]<br />
[1-2,2-5]<br />
[/cc]</p>

<p>但你不希望用循环完成这个工作，那么你可能想到利用B创建一个和A一样维度的矩阵然后进行.-：<br />
[cc lang="text"]<br />
C = [2,5;2,5;2,5]<br />
A .- C<br />
[/cc]</p>

<p>在Octave中可以利用repmat这个函数获得C：<br />
[cc lang="text"]<br />
C = repmat(B, length(A), 1)<br />
[/cc]<br />
但是对于大矩阵来说这是一种对内存的浪费。</p>

<p>更好的方法是利用bsxfun：<br />
[cc lang="text"]<br />
bsxfun(@minus, A, B)<br />
[/cc]</p>

<p>bsxfun在octave的文档中似乎鲜有提及。
</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">手动设置Fedora15网卡</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/05/28/%E6%89%8B%E5%8A%A8%E8%AE%BE%E7%BD%AEfedora15%E7%BD%91%E5%8D%A1/"/>
    
    <id>/blog/2011/05/28/手动设置fedora15网卡</id>
    <published>2011-05-28T00:00:00+08:00</published>
    <updated>2011-05-28T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>今天上午的Fedora更新，版本为<font face="monospace">0.8.999.3</font>的NetworkManager会致使NetworkManager和network service的版本不一致，从而导致网络功能无法使用。而这个时候要通过<font face="monospace">yum downgrade NetworkManager*</font>降级又没有网络连接可用，悲剧。</p>

<p>这时只有手动设置网卡了。<font face="monospace">service network restart</font>和 <font face="monospace">service NetworkManager restart</font>都报告失败，<font face="monospace">ifconfig</font>查看网卡，只有本地回环启动。</p>

<p>接下来接上网线，通过 <font face="monospace">ifconfig -a</font> 查看所有的网卡接口，例如我的接口叫做<font face="monospace">em2</font>.</p>

<p>启动网卡
<font face="monospace">ifconfig em2 up</font></p>

<p>查看网卡情况
<font face="monospace">ifconfig em2</font></p>

<p>如果没有获得ip，可以通过dhcpclient获得ip
<font face="monospace">dhclient -4 em2</font></p>

<p>再查看网卡情况，如果获得了ip，可以尝试<font face="monospace">ping www.baidu.com</font>，如果出现network unreachable的报错，需要再配置一下路由信息，其中gw是你的网关：
<font face="monospace">route add default gw 192.168.1.1</font></p>

<p>这时你的网络应该暂时可用了，立刻执行<font face="monospace">yum downgrade NetworkManager*</font>降级吧。<br /><br /><div class="zemanta-pixie"><img class="zemanta-pixie-img" alt="" src="http://img.zemanta.com/pixy.gif?x-id=551018aa-7e6c-81e6-b79a-bc1751d9b7be" /></div></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Correct Source File Encoding With One Liner</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/03/08/correct-source-file-encoding-with-one-liner/"/>
    
    <id>/blog/2011/03/08/correct-source-file-encoding-with-one-liner</id>
    <published>2011-03-08T00:00:00+08:00</published>
    <updated>2011-03-08T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p><a href="http://amoeba.meidusa.com/wordpress/">Amoeba</a>项目最早的代码可以追溯到2008年了，其中有多个作者贡献代码，因为一直在Windows下开发，所以没有使用UTF8编码，最近大家统一到UTF8，遇到了代码编码不正确的问题。</p>

<p>于是我们需要统一解决一下这个问题：
<code>iconv -f gbk -t utf8 -o ConnectionManager.java ConnectionManager.java</code></p>

<p>这样可以把gbk编码的源文件转换为UTF8，原地转换。</p>

<p>推广到整个代码目录，用find和xargs做，xargs通过-I来制定一个占位符。
<code>find . -name "*.java" -type f -perm +600 -print | xargs -I _ iconv -f gbk -t utf8 -o _ -c _</code></p>

<p>结果发现iconv运行中报了错，进一步检查发现一部分代码正常转换了，另一部分却乱码了。原来，两个作者的代码分别是gbk和gb2312，这iconv转换的时候两种编码并不兼容。这就麻烦了，必须对代码分别处理才可以，区别代码的编码，暂时就用Java源文件里的作者名字。又看了一下find似乎没有对文件内容过滤的条件，不过不要紧，我们可以用xargs做：
<code>find . -name "*.java" -type f -perm +600 -print | xargs -I _ sh -c 'grep -q hexianmao _ && iconv -f gb2312 -t utf8 -o _ -c _ '</code></p>

<p>对这位hexianmao作者的代码，我们利用grep进程的返回值来进行判断。grep的-q参数相当于>/dev/null。这里有一个tricky的地方，再xargs里我们不能直接用&&来组合命令，不过可以通过sh -c这样的方式，并且其中的占位符会被xargs合适地替换掉。</p>

<p>这样执行之后，这位作者的gb2312代码就被成功转换了。而另一部分作者的gbk代码也可以用同样方式解决了。</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Fix Ogg/oga Not Play in Firefox 3.6</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2011/02/15/fix-oggoga-not-play-in-firefox-3-6/"/>
    
    <id>/blog/2011/02/15/fix-oggoga-not-play-in-firefox-3-6</id>
    <published>2011-02-15T00:00:00+08:00</published>
    <updated>2011-02-15T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>Native audio support was introduced in since Firefox 3.5 . Ogg is one of the media format supported by Firefox. However, sometimes you may find it doesn't work even if you set the right source path.  And you just check the network status of audio element:</p>

<p><i>document.getElementsByTagName("audio")[0].networkState</i></p>

<p>Then you get the constant of a 4, which is HTMLMediaElement.NETWORK_NO_SOURCE.</p>

<p>This is because firefox checks the Content-Type header to make sure it's a media file. (Webkit based browsers don't have this restriction.) However, ogg format is not configured on most http servers. You can check the content type by:
<i>curl -I &lt;url-to-media-file&gt;</i></p>

<p>Take Apache as example, you can add following content to your configuration file:
<i>AddType audio/ogg .oga</i>
<i>AddType video/ogg .ogv .ogg</i></p>

<p>For more, check this article:
<a href="https://developer.mozilla.org/en/Configuring_servers_for_Ogg_media">https://developer.mozilla.org/en/Configuring_servers_for_Ogg_media</a></p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">The 4k Story</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2010/10/08/the-4k-story/"/>
    
    <id>/blog/2010/10/08/the-4k-story</id>
    <published>2010-10-08T00:00:00+08:00</published>
    <updated>2010-10-08T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>从 Redis 2.0 开始，Redis的作者就不断地被问道，你为什么要自己造一个VM轮子呢。尽管作者在<a href="http://code.google.com/p/redis/wiki/FAQ#Do_you_plan_to_implement_Virtual_Memory_in_Redis?_Why_don%27t">FAQ</a>里说明了，但是仍然有很多不同意见。</p>

<p>反向代理Varnish的开发人员，Poul-Henning Kamp 写了一篇文章，<a href="http://www.varnish-cache.org/trac/wiki/ArchitectNotes">What's wrong with 1975 programming ?</a>，锋芒毕露，矛头直指竞争对手Squid，顺便也打击一大片牵连到了Redis的作者Antirez。他说：
<blockquote>I have spent many years working on the FreeBSD kernel, and only rarely did I venture into userland programming, but when I had occation to do so, I invariably found that people programmed like it was still 1975. </blockquote>
Kamp兄有来到user-space之后一夜回到解放前的感觉，又好像摇晃着饮料瓶子对着Antirez说：你Out啦！也许是因为作者就是个内核开发者，所以Varnish对操作系统的Virtual Memory机制充分信任，把Squid对内存的手动管理称为wasted work。"So Welcome to Varnish, a 2006 architecture program. "</p>

<p>还有<a href="http://blog.kennejima.com/post/1226487020/thoughts-on-redis">用户</a>也提出
<blockquote>
Redis doesn’t use OS swap. According to Salvatore Sanfilippo, the creator of Redis, it was because the page size of 4KB was too big. I personally don’t think that helps but it’d be better if Redis preallocated specified amount of buffer pool and bring related objects to the same page to increase locality of reference, instead of letting the heap manager blindly fragment objects. In my opinion, the page size of 32 bytes is too small, considering that the hardware architectures and the compilers are optimized for the conventional page size. In that scale, even the latency of reading something from RAM could be dominant (RAM is too slow for CPU, therefore it’s got L1/L2 cache), and RAM has the pipelined burst mode to pre-fetche memory contents at a few clock cycles, before they are actually requested.
</blockquote></p>

<p>5号，Antirez在博客上写了回击 <a href="http://antirez.com/post/what-is-wrong-with-2006-programming.html">What's wrong with 2006 programming?</a>，他认为：
<ul>
<li>OS Swap在一些情况下会导致客户端阻塞</li>
<li>4K大小的Page可能包含很多key，其中总有一些被访问到，导致操作系统无法swap这些page</li>
<li>使用自己实现的Paging为程序提供了极大的自由度，包括作者提到的2.2将会引入的数据压缩、新的数据结构以及自定义的过期算法</li>
</ul></p>

<p>前段时间，Foursquare用MongoDB时，因为Sharding方法一些疏漏把大量的数据集中到了一台机器上，导致一台EC2实例内存耗尽无法工作。Mongodb的内部机制就是mmap，我的同事做过相关的测试，当内存耗尽时，读写操作都使用磁盘，这时mongodb的性能是完全无法使用的。事后10gen的开发人员Horowitz总结出现问题的原因<a href="http://groups.google.com/group/mongodb-user/browse_thread/thread/528a94f287e9d77e">总结出现问题的原因</a>时，其中很重要的一点是
<blockquote>Document size is less than 4k. Such documents, when moved, may be too small to free up pages and, thus, memory. </blockquote></p>

<p>看了这个原因，Redis的作者Twitter上大喜："Real world instance of my 4k page + small objects concerns"</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Visualize Call Tree of a C Function</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2010/09/24/visualize-call-tree-of-a-c-function/"/>
    
    <id>/blog/2010/09/24/visualize-call-tree-of-a-c-function</id>
    <published>2010-09-24T00:00:00+08:00</published>
    <updated>2010-09-24T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p><h3>Requirement</h3>
You want to visualize a call hierarchy of a C function.</p>

<p><h3>Solution</h3>
Utilities you need are listed below:
<ul>
<li><a href="http://www.gnu.org/software/cflow/">GNU cflow</a></li>
<li><a href="http://cflow2vcg.sourceforge.net/">cflow2vcg</a></li>
<li>graphviz</li>
</ul></p>

<p>Take 'rdbSaveBackground' (<a href="http://github.com/antirez/redis/blob/master/src/rdb.c">redis/rdb.c</a>) for example:<br />
[cc lang="bash"]<br />
cflow --format=posix --omit-arguments --level-indent='0=\t' --level-indent='1=\t' --level-indent=start='\t' -m 'rdbSaveBackground' ~/osprojects/redis/src/rdb.c | cflow2dot | dot -Tjpg -o rdb.jpg<br />
[/cc]</p>

<p>Output:
<a href="http://www.flickr.com/photos/40741608@N08/5020142591/" title="visualization of a call tree by 贝小塔, on Flickr"><img src="http://farm5.static.flickr.com/4111/5020142591_7b34a52e3c.jpg" width="500" height="98" alt="visualization of a call tree" /></a></p>

<p>Source: <a href="http://unixdiary.blogspot.com/2006/05/using-cflow.html">unix diary</a></p>

<p>The post is brought to you by <a href="http://fedorahosted.org/lekhonee">lekhonee</a> v0.7</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Bayeux Protocol</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2010/07/17/bayeux-protocol/"/>
    
    <id>/blog/2010/07/17/bayeux-protocol</id>
    <published>2010-07-17T00:00:00+08:00</published>
    <updated>2010-07-17T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>运行一个CometD Demo非常简单，只要创建一个Maven项目即可（<a href="http://cometd.org/documentation/howtos/primer">CometD Howtos</a>）：
<i>$ mvn archetype:generate -DarchetypeCatalog=http://cometd.org</i></p>

<p>maven会提示用户选择archetype，包括cometd的版本1、版本2，jetty6、jetty7的实现，以及客户端dojo或jquery的实现。这里可以选择最新的：
<i>http://cometd.org -> cometd-archetype-dojo-jetty7 (2.0.0 - CometD archetype for creating a server-side event-driven web application)</i></p>

<p>项目创建完成后执行mvn jetty:run即可，打开http://127.0.0.1:8080/{artifactId}即可。</p>

<p>CometD的协议包容了各种主要的浏览器，比如在Chromium 5上，dojo采用WebSocket实现；而在不支持WebSocket的Firefox 3上，通过long-polling实现。Bayuex是一个应用协议，CometD是Bayuex的实现，类似鸡与蛋的关系。</p>

<p>有了昨天在Chromium上看WebSocket协议的经验，先看一下CometD的WebSocket实现：<br />
握手。客户端请求/{artifactId}/cometd/handshake<br />
包含Header
<blockquote>GET /cometd-jetty/cometd/handshake HTTP/1.1<br />
Upgrade: WebSocket<br />
Connection: Upgrade<br />
Host: 127.0.0.1:8080<br />
Origin: http://127.0.0.1:8080<br />
Cookie: JSESSIONID=12jqq6hbsfkfic8vzqpevxtrw
</blockquote></p>

<p>这是标准的WebSocket握手协议，服务端返回：</p>

<p><blockquote>HTTP/1.1 101 Web Socket Protocol Handshake<br />
Upgrade: WebSocket<br />
Connection: Upgrade<br />
WebSocket-Origin: http://127.0.0.1:8080<br />
WebSocket-Location: ws://127.0.0.1:8080/cometd-jetty/cometd/handshake</blockquote></p>

<p>双方完成WebSocket连接的建立。客户端通过websocket发送JSON，进行bayuex的握手：</p>

<p><blockquote>[{"version":"1.0","minimumVersion":"0.9","channel":"/meta/handshake","supportedConnectionTypes":["websocket","long-polling","callback-polling"],"advice":{"timeout":60000,"interval":0},"id":"1"}]</blockquote></p>

<p>服务端返回JSON，下发clientId完成握手：</p>

<p><blockquote>[{"channel":"/meta/handshake","clientId":"8g6dbnlqr2k6jfo1tdpaeb7iw","version":"1.0","successful":true,"minimumVersion":"1.0","id":"1","supportedConnectionTypes":["websocket","long-polling","callback-polling"]}]</blockquote></p>

<p>握手完成，bayuex连接建立。</p>

<p>在Demo中，客户端添加了一个handshake的listerner<br />
[cc lang="javascript"]<br />
    function _metaHandshake(handshake)<br />
    {<br />
        if (handshake.successful === true)<br />
        {<br />
            cometd.batch(function()<br />
            {<br />
                cometd.subscribe('/hello', function(message)<br />
                {<br />
                    dojo.byId('body').innerHTML += '<div>Server Says: ' + message.data.greeting + '</div>';<br />
                });<br />
                // Publish on a service channel since the message is for the server only<br />
                cometd.publish('/service/hello', { name: 'World' });<br />
            });<br />
        }<br />
    }<br />
[/cc]<br />
所以在完成握手后，客户端发送一个批量请求，subscribe /hello频道，并且向/service/hello发送json格式的消息。向/service channel发送的信息<a href="http://svn.cometd.com/trunk/bayeux/bayeux.html#toc_81">表示客户端与服务端的单独通信</a>，不会被转发给其他客户端。<br />
id用于区分每个请求，<a href="http://svn.cometd.com/trunk/bayeux/bayeux.html#toc_38">bayuex spec规定</a>向/meta和/service发送的请求必须包含id字段，用于标示请求响应。<br />
请求的内容最终聚合为一个Json</p>

<p><blockquote>[{"channel":"/meta/subscribe","subscription":"/hello","id":"2","clientId":"8g6dbnlqr2k6jfo1tdpaeb7iw"},{"channel":"/service/hello","data":{"name":"World"},"id":"3","clientId":"8g6dbnlqr2k6jfo1tdpaeb7iw"}]</blockquote></p>

<p>服务端发回响应，id=2的请求成功，订阅/hello频道成功</p>

<p><blockquote>[{"channel":"/meta/subscribe","successful":true,"id":"2","subscription":"/hello"}]</blockquote></p>

<p>之后，服务端发回/hello channel的消息</p>

<p><blockquote>[{"channel":"/hello","data":{"greeting":"Hello, World"}},{"channel":"/service/hello","successful":true,"id":"3"}]</blockquote></p>

<p>客户端还要定期发送连接请求保持连接</p>

<p><blockquote>[{"channel":"/meta/connect","connectionType":"websocket","advice":{"timeout":0},"id":"4","clientId":"8g6dbnlqr2k6jfo1tdpaeb7iw"}]</blockquote></p>

<p>服务端返回，连接成功</p>

<p><blockquote>[{"channel":"/meta/connect","advice":{"reconnect":"retry","interval":2500,"timeout":15000},"successful":true,"id":"4"}]</blockquote></p>

<p>connect请求是用于在客户端和服务端维持连接， Bayeux标准中提到(<a href="http://svn.cometd.com/trunk/bayeux/bayeux.html#toc_52">1</a>, <a href="http://svn.cometd.com/trunk/bayeux/bayeux.html#toc_53">2</a>)：</p>

<p><blockquote>A transport MUST maintain one and only one outstanding connect message. When a HTTP response that contains a /meta/connect response terminates, the client MUST wait at least the interval specified in the last received advice before following the advice to reestablish the connection </blockquote></p>

<p><blockquote>
The client MUST maintain only a single outstanding connect message. If the server does not have a current outstanding connect and a connect is not received within a configured timeout, then the server SHOULD act as if a disconnect message has been received. </blockquote></p>

<p>至此，cometd客户端就可以在/hello频道上订阅、发布消息了。<br />
在Chromium上，所有的操作都在一个WebSocket连接上完成。</p>

<p>而当断开连接时，客户端向服务端发送</p>

<p><blockquote>[{"channel":"/meta/disconnect","id":"188","clientId":"a8iutjvfp7dtwhzrfujeonk5q"}]</blockquote></p>

<p>服务端响应</p>

<p><blockquote>[{"channel":"/meta/disconnect","successful":true,"id":"188"}]</blockquote></p>

<p>Bayuex基本上就可以理解为一个websocket上的应用协议了。</p>

<p>再看看Firefox 3.6上的实现。Firefox 3.6不支持WebSocket，所有的通信只能通过XHR来实现。<br />
握手，通过一个xhr post请求实现：</p>

<p><blockquote>POST /{artifactId}/cometd/handshake HTTP/1.1<br />
Host: 127.0.0.1:8080<br />
User-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.2.6) Gecko/20100628 Ubuntu/10.04 (lucid) Firefox/3.6.6<br />
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br />
Accept-Language: en-us,en;q=0.5<br />
Accept-Encoding: gzip,deflate<br />
Accept-Charset: UTF-8,*<br />
Keep-Alive: 115<br />
Connection: keep-alive<br />
Content-Type: application/json;charset=UTF-8<br />
X-Requested-With: XMLHttpRequest<br />
Referer: http://127.0.0.1:8080/{artifactId}/<br />
Content-Length: 182<br />
Cookie: JSESSIONID=fjnyxb28raih1cnaljrijl1ic<br />
Pragma: no-cache<br />
Cache-Control: no-cache
</blockquote></p>

<p>服务器端响应：</p>

<p><blockquote>HTTP/1.1 200 OK<br />
Content-Type: application/json;charset=UTF-8<br />
Set-Cookie: BAYEUX_BROWSER=df92-h8q89f416mutgbpxrwb8185u;Path=/<br />
Content-Length: 213<br />
Server: Jetty(7.1.5.v20100705)</blockquote></p>

<p>[{"channel":"/meta/handshake","clientId":"9185k23lo482oq1po3ivxup2cj","version":"1.0","successful":true,"minimumVersion":"1.0","id":"1","supportedConnectionTypes":["websocket","long-polling","callback-polling"]}]</p>

<p>握手完成，执行客户端定义的回调。发送bayeux请求，通过一个新的XHR上<br />
[{"channel":"/meta/subscribe","subscription":"/hello","id":"2","clientId":"9185k23lo482oq1po3ivxup2cj"},{"channel":"/service/hello","data":{"name":"World"},"id":"3","clientId":"9185k23lo482oq1po3ivxup2cj"}]</p>

<p>服务端同时返回三个bayuex的请求响应</p>

<p><blockquote>[{"channel":"/meta/subscribe","successful":true,"id":"2","subscription":"/hello"},{"channel":"/hello","data":{"greeting":"Hello, World"}},{"channel":"/service/hello","successful":true,"id":"3"}]</blockquote></p>

<p>客户端开始发送连接请求</p>

<p><blockquote>[{"channel":"/meta/connect","connectionType":"long-polling","advice":{"timeout":0},"id":"4","clientId":"9185k23lo482oq1po3ivxup2cj"}]</blockquote></p>

<p>注意这里使用的是<a href="http://svn.cometd.com/trunk/bayeux/bayeux.html#toc_69">long-polling</a>方式，这是由dojo针对浏览器特性决定的。</p>

<p><blockquote>Long-polling server implementations attempt to hold open each request until there are events to deliver; the goal is to always have a pending request available to use for delivering events as they occur, thereby minimizing the latency in message delivery.</blockquote></p>

<p>如果没有新消息，服务端阻塞十秒后返回</p>

<p><blockquote>[{"channel":"/meta/connect","successful":true,"id":"7"}]</blockquote></p>

<p>客户端接收到返回立刻发起新的connect请求</p>

<p>当有新消息时，阻塞在服务器端的connect请求会立即返回，同时带回新的消息，如
<blockquote>[{"channel":"/hello","data":{"name":"555"},"id":"6"},{"channel":"/meta/connect","successful":true,"id":"619"}]</blockquote>
而如果是本客户端publish的新消息，会在请求成功的响应中返回，不会影响connect连接，如：
<blockquote>[{"channel":"/hello","data":{"name":"nihao"},"id":"715"},{"channel":"/hello","successful":true,"id":"715"}]</blockquote></p>

<p>断开时，仍然是通过xhr post一条bayuex命令到服务端
<blockquote>[{"channel":"/meta/disconnect","id":"750","clientId":"9185k23lo482oq1po3ivxup2cj"}]</blockquote>
服务端响应：
<blockquote>[{"channel":"/meta/disconnect","successful":true,"id":"750"}]</blockquote></p>

<p>至此，通过long polling方式实现bayuex的cometd客户端也描述清楚了。long-polling仍然是通过connect请求来实现pull的方式准实时，与websocket真正push的方式还是存在区别的。</p>

<p>The post is brought to you by <a href="http://fedorahosted.org/lekhonee">lekhonee</a> v0.7</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Websocket Protocol</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2010/07/16/websocket-protocol/"/>
    
    <id>/blog/2010/07/16/websocket-protocol</id>
    <published>2010-07-16T00:00:00+08:00</published>
    <updated>2010-07-16T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>下午用jetty的WekSocketServlet写了一个简单的WebIM程序，正好第一次瞥见WebSocket的狰容。</p>

<p>服务器端<br />
jetty 7.1.5<br />
客户端<br />
Chromium 5.0.375.86</p>

<p>通过wireshark抓包获得这样一些数据：
<em>var _ws = new WebSocket("ws://127.0.0.1:8080/nothing")</em>
这个环节创建WebSocket，浏览器与服务器端进行handshake，发送请求</p>

<p><blockquote>GET /nothing HTTP/1.1<br />
Upgrade: WebSocket<br />
Connection: Upgrade<br />
Host: 127.0.0.1:8080<br />
Origin: http://127.0.0.1:8080</blockquote></p>

<p>客户端发出一个Upgrade头，upgrade头在<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.42">RFC2616 14.42</a>定义</p>

<p><blockquote>The Upgrade general-header allows the client to specify what additional communication protocols it supports and would like to use if the server finds it appropriate to switch protocols. </blockquote></p>

<p>Upgrade必须被放入Connection头中标示这是一个Upgrade请求<br />
Connection定义在<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.10">RFC2616 14.10</a>中：</p>

<p><blockquote>The Connection general-header field allows the sender to specify options that are desired for that particular connection and MUST NOT be communicated by proxies over further connections. </blockquote></p>

<p>Origin头还没有进入RFC，他的标准草案可以在<a href="http://tools.ietf.org/html/draft-abarth-origin-07">这里</a>找到，W3C的标准草案<a href="http://dev.w3.org/2006/waf/access-control/">Cross-Origin Resource Sharing</a>里<a href="http://dev.w3.org/2006/waf/access-control/#origin-request-header">定义</a>Origin Header：</p>

<p><blockquote>The Origin  header indicates where the cross-origin request or preflight request  originates from. </blockquote></p>

<p>Origin头的提出是为了解决<a href="http://en.wikipedia.org/wiki/Cross_Site_Request_Forgery">CSRF</a>的潜在危险，通过Origin服务器端可以获知请求的来源，进而判断其合法性。也就是说将跨域安全性检查的责任交给了服务器端，浏览器端采取信任的策略，避免了原先对跨域一棍子打死的做法。<br />
Jetty 7的org.eclipse.jetty.servlets.CrossOriginFilter对这个头进行了处理。</p>

<p>此外，handshake请求的header中还允许一个Sec-WebSocket-Protocol，用于对服务器端指定一个子协议（应用协议）。</p>

<p>服务器端应答</p>

<p><blockquote>HTTP/1.1 101 Web Socket Protocol Handshake<br />
Upgrade: WebSocket<br />
Connection: Upgrade<br />
WebSocket-Origin: http://127.0.0.1:8080<br />
WebSocket-Location: ws://127.0.0.1:8080/nothing</blockquote></p>

<p>Websocket连接建立。此后，服务器端和客户端可以实现bidirectional的通信，消息体即websocket.send(msg)中的纯文本。要实现这样的机制，浏览器和服务器间需要建立至少两个连接。目前，<a href="http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76#4">WebSocket协议</a>中还没有规定客户端对服务器端的连接数限制。不过关于这个限制，RFC2616（HTTP1.1）中<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.1.4">规定</a>：</p>

<p><blockquote>Clients that use persistent connections SHOULD limit the number of simultaneous connections that they maintain to a given server. A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy. </blockquote></p>

<p>对此，另一个Bayeux协议倒是已经有了明确的限制：</p>

<p><blockquote>the Bayeux protocol MUST NOT require any more than 2 HTTP requests to be simultaneously handled by a server in order to handle all application (Bayeux based or otherwise) requests from a client. </blockquote></p>

<p>到此，客户端和服务器端已经可以建立双工的通信，这也是浏览器级别实现WebSocket协议的最大优点。而对于Firefox 3.x， IE x.x等等，只能在现有的HTTP连接机制上实现WebSocket，如通过long polling和callback polling的方式，但终归无法实现真正双工的通信。</p>

<p>The post is brought to you by <a href="http://fedorahosted.org/lekhonee">lekhonee</a> v0.7</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Fixing "Libmozjs" Missing When Using Mongodb on Ubuntu Lucid</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2010/07/13/fixing-libmozjs-missing-when-using-mongodb-on-ubuntu-lucid/"/>
    
    <id>/blog/2010/07/13/fixing-libmozjs-missing-when-using-mongodb-on-ubuntu-lucid</id>
    <published>2010-07-13T00:00:00+08:00</published>
    <updated>2010-07-13T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p><strong>Problem</strong>
When running mongod/mongo/mongos, you got message like this:
<i>mongod: error while loading shared libraries: libmozjs.so: cannot open shared object file: No such file or directory</i></p>

<p><strong>Solution</strong>
Make sure you have xulrunner-dev installed:
<em>sudo apt-get install xulrunner-dev</em></p>

<p>then find libmozjs on your filesystem:
<em>sudo locate libmozjs</em></p>

<p>in lucid, it's supposed to locate at:
<em>/usr/lib/xulrunner-1.9.2.6/libmozjs.so</em></p>

<p>(and some other directories, such as firefox / thunderbird / seamonkey)</p>

<p>Just create a symbol link:
<em>sudo ln -s /usr/lib/xulrunner-1.9.2.6/libmozjs.so /usr/lib/</em></p>

<p>try to restart mongodb:
<em>sudo service mongodb start</em></p>

<p>take a look at process list:
<em>ps aux | grep mongo</em></p>

<p>it works.</p>

<p>The post is brought to you by <a href="http://fedorahosted.org/lekhonee">lekhonee</a> v0.7</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Python获取本机IP</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2010/06/05/python%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip/"/>
    
    <id>/blog/2010/06/05/python获取本机ip</id>
    <published>2010-06-05T00:00:00+08:00</published>
    <updated>2010-06-05T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>除了用<a href="http://alastairs-place.net/netifaces/">inetface</a>库和分析ifconfig输出以外，一个比较简单的获取本机IP的方法：<br />
[cc lang="python"]<br />
import socket<br />
def get_local_ip():<br />
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)<br />
    s.connect(("sdo.com",80))<br />
    return s.getsockname()[0]<br />
[/cc]</p>

<p>参考 http://stackoverflow.com/questions/166506/finding-local-ip-addresses-in-python</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">Maven Recipe #1: Test Java Code With Groovy</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2010/05/19/maven-recipe-1-test-java-code-with-groovy/"/>
    
    <id>/blog/2010/05/19/maven-recipe-1-test-java-code-with-groovy</id>
    <published>2010-05-19T00:00:00+08:00</published>
    <updated>2010-05-19T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>问题： 受够了，不想写Java了，写个含有数据的map还要new出来一个一个put进去，想用groovy解决单元测试<br />
解决： gmaven+groovy eclipse插件可以解决这个需求<br />
在pom.xml中添加gmaven的依赖，注意，仅用来测试。老大不让生产代码里有不可靠的东西。<br />
[cc lang="xml"]<br />
...<br />
        <dependency>
            <groupid>org.codehaus.groovy.maven.runtime</groupid>
            <artifactid>gmaven-runtime-default</artifactid>
            <version>1.0-rc-3</version>
            <scope>test</scope>
        </dependency>
...<br />
            <plugin>
                <groupid>org.codehaus.groovy.maven</groupid>
                <artifactid>gmaven-plugin</artifactid>
                <version>1.0-rc-3</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>generateStubs</goal>
                            <goal>compile</goal>
                            <goal>generateTestStubs</goal>
                            <goal>testCompile</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
[/cc]</p>

<p>在eclipse中新建source folder, <em>src/test/groovy</em>，在其中创建groovy test case即可</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">开始实践Poromodo Technique</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2010/05/12/%E5%BC%80%E5%A7%8B%E5%AE%9E%E8%B7%B5poromodo-technique/"/>
    
    <id>/blog/2010/05/12/开始实践poromodo-technique</id>
    <published>2010-05-12T00:00:00+08:00</published>
    <updated>2010-05-12T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>看了@juvenxv的博客介绍<a href="http://book.douban.com/subject/4199701/">Poromodo Technique Illustrated</a>一书，结合我现在低下的工作效率，我决定实践一下这个方法。
<ul>
	<li>一张TODO表记录今天的计划</li>
	<li>一张Activity Inventory表用于记录长期的任务，标记已完成的任务</li>
	<li>一张Record表统计每天完成的任务数量</li>
</ul></p>

<p>一个Poromodo持续25分钟，在这25分钟内只专注当前任务。Poromodo间隙用来给大脑做缓冲，清空前一个任务的影响，以便下一个Poromodo开始时快速切换到相应任务。</p>

<p>应对Interruption，对internal的accept, record & continue，一个poromodo作为一个原子单元不可被打断，一旦被打断应该重新开始。<br />
对external的，评估重要性，分别拒绝、延后、安排时间、安排回调。</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">交通游戏OpenTTD</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2010/05/02/openttd/"/>
    
    <id>/blog/2010/05/02/openttd</id>
    <published>2010-05-02T00:00:00+08:00</published>
    <updated>2010-05-02T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p>我总是对这种城市建设、交通规划一类的游戏欲罢不能，以前在Linux上一直只是玩<a href="http://lincity-ng.berlios.de/">Lincity</a>，后来发现了纯交通类的<a href="http://www.simutrans.com/">simutrans</a>，最近升级到Ubuntu10.04以后，终于可以玩这个六年磨一剑，精雕细琢的<a href="http://openttd.org">OpenTTD</a>了。</p>

<p><a href="http://www.flickr.com/photos/40741608@N08/4571371260/" title="Chindhattan Springs Transport, 19th Dec 1953 by 贝小塔, on Flickr"><img src="http://farm4.static.flickr.com/3521/4571371260_ce28e57779.jpg" width="500" height="284" alt="Chindhattan Springs Transport, 19th Dec 1953" /></a></p>

<p>可以建造各种客运货运的汽车站、火车站，机场，码头等等，可以建设道路、铁路，可以购买公交车、卡车、火车头、火车车厢等等。可惜我玩了大半天还不知道怎么盈利。。。</p>



]]>
    </content>
  </entry>

  <entry>
    <title type="html">My First Hello World Web App Using Compojure</title>
    
    <link rel="alternate" type="text/html" href="http://sunng87.github.io/blog/blog/blog/2010/04/24/my-first-hello-world-web-app-using-compojure/"/>
    
    <id>/blog/2010/04/24/my-first-hello-world-web-app-using-compojure</id>
    <published>2010-04-24T00:00:00+08:00</published>
    <updated>2010-04-24T00:00:00+08:00</updated>
    <author>
      <name>Sun Ning</name>
      <uri>http://sunng87.github.io/blog/blog/</uri>
    </author>
    <content type="html" xml:base="http://sunng87.github.io/blog/blog/" >
<![CDATA[

<p><a href="http://github.com/weavejester/compojure">Compojure</a>是一个用<a href="http://clojure.org/">Clojure</a>写成的类似<a href="http://www.sinatrarb.com/">Sinatra</a>的Web框架。<a href="http://github.com/technomancy/leiningen">Leiningen</a>是一个新的Clojure构建工具，它用Maven来处理依赖管理，而通过封装<a href="http://github.com/stuarthalloway/lancet">Lancet</a>（基于Ant）来实现build-in的task。</p>

<p>以上是背景介绍。以下是HelloWorld。</p>

<p>创建一个目录作为工程目录<br />
[cc lang="bash"]<br />
mkdir compojure-app<br />
cd compojure-app<br />
[/cc]</p>

<p>像创建build.xml和pom.xml一样创建project.clj<br />
[cc lang="lisp"]<br />
(defproject info.sunng/compojure-app "0.0.1"<br />
		:description "A demo app running on compojure framework"<br />
		:dependencies [[org.clojure/clojure "1.1.0"]<br />
						[org.clojure/clojure-contrib "1.1.0"]<br />
						[compojure "0.3.2"]]<br />
		:dev-dependencies [[leiningen/lein-swank "1.1.0"]]<br />
		:main info.sunng.compojureapp.helloworld)<br />
[/cc]<br />
首行定义了项目的groupId, artifactId和version，其后的是maven风格的依赖定义，最后我们还定义了程序的主类。</p>

<p>这个helloworld只有一个文件，被放在src/info/sunng/compojureapp/目录下<br />
[cc lang="lisp"]<br />
(ns info.sunng.compojureapp.helloworld (:gen-class) (:use compojure))</p>

<p>(defroutes example-routes<br />
	(GET "/" "Hello W0rld")<br />
	(ANY "*" [404 "Page Not Found"]))</p>

<p>(defn -main []<br />
	(run-server {:port 8080} "/*" (servlet example-routes)))<br />
[/cc]<br />
中间就是Sinatra风格的URL映射定义，最后在主类中通过一个run-server方法以嵌入式的方式运行一个jetty</p>

<p>回到工程目录，执行构建<br />
[cc lang="bash"]<br />
lein deps<br />
lein compile<br />
lein uberjar<br />
[/cc]</p>

<p>通过uberjar可以将依赖通通打入一个jar包中，接着就可以通过
<em>java -jar compojure-app-standalone.jar </em>
启动你的Web程序了，很酷吧</p>

<p>除了这种方式，还可以通过
<em>lein swank</em>
启动一个<a href="http://github.com/technomancy/leiningen/tree/master/lein-swank">swank</a> server（project.clj中定义了dev-dependency），再用Emacs的<a href="http://common-lisp.net/project/slime/">SLIME</a>交互式地运行程序。</p>

<p>参考
<ul>
	<li><a href="http://kzar.co.uk/blog/view/simple-compojure-project">http://kzar.co.uk/blog/view/simple-compojure-project</a></li>
        <li><a href="http://schipplock.de/2010/01/31/clojure-web-framework-compojure/">http://schipplock.de/2010/01/31/clojure-web-framework-compojure/</a></li>
        <li><a href="http://zef.me/2470/building-clojure-projects-with-leiningen">http://zef.me/2470/building-clojure-projects-with-leiningen</a></li></ul></p>

<p></p>



]]>
    </content>
  </entry>

</feed>
